--------------------------------------------------------
-- Interpretation of well-typed terms in time-indexed --
--------------------------------------------------------

open import Function

open import Data.Nat
open import Data.Nat.Properties
open import Data.Product

import Relation.Binary.PropositionalEquality as Eq
open Eq hiding ([_])
open Eq.â‰¡-Reasoning

open import Language
open import TSets

module Interpretation where

-- Base types are interpreted as constant presheaves

BaseTSet : BaseType â†’ TSet
BaseTSet B = tset (Î» _ â†’ BaseSet B) (Î» _ â†’ id)

constáµ— : âˆ€ {B} â†’ BaseSet B â†’ ğŸ™áµ— â†’áµ— BaseTSet B
constáµ— c = tset-map (Î» _ â†’ c)

-- Interpretation of ground types

âŸ¦_âŸ§áµ : GType â†’ TSet
âŸ¦ Base B âŸ§áµ = BaseTSet B
âŸ¦ Unit âŸ§áµ   = ğŸ™áµ—
âŸ¦ Empty âŸ§áµ  = ğŸ˜áµ—

âŸ¦âŸ§áµ-constant : (B : GType) â†’ (t t' : Time) â†’ carrier âŸ¦ B âŸ§áµ t â†’ carrier âŸ¦ B âŸ§áµ t'
âŸ¦âŸ§áµ-constant (Base B) t t' = id
âŸ¦âŸ§áµ-constant Unit     t t' = id
âŸ¦âŸ§áµ-constant Empty    t t' = id

-- Free graded monad generated by algebraic operations in Op

---- object-mapping of the underlying functor

data TË¢ (A : TSet) : (Ï„ : Time) â†’ (t : Time) â†’ Set where  -- 1st time index (Ï„) is the duration of the computation (its time-grading)
                                                          -- 2nd time index (t) is the corresponding TSets' time-index (modal time)
  leaf : âˆ€ {Ï„ t}
       â†’ carrier A (Ï„ + t)
       â†’ TË¢ A Ï„ t

  node : âˆ€ {Ï„ Ï„' t}
       â†’ (op : Op)
       â†’ carrier âŸ¦ param op âŸ§áµ t
       â†’ ({t' : Time} â†’ t + op-time op â‰¤ t' â†’ carrier (âŸ¦ arity op âŸ§áµ) t' â†’ TË¢ A Ï„ t')  -- intuitively, [ op-time op ] (âŸ¦ arity op âŸ§áµ â‡’áµ— Táµ’ A Ï„)
       â†’ Ï„' â‰¡ op-time op + Ï„                                                           -- abstracting into a variable for easier recursive defs.
       â†’ TË¢ A Ï„' t

---- monotonicity wrt TSets' time-indices

TË¢-â‰¤t : âˆ€ {A Ï„ t t'} â†’ t â‰¤ t' â†’ TË¢ A Ï„ t â†’ TË¢ A Ï„ t'
TË¢-â‰¤t {(tset A Af)} p (leaf a) =
  leaf (Af (+-monoÊ³-â‰¤ _ p) a)
TË¢-â‰¤t {(tset A Af)} p (node op v k q) =
  node
    op (monotone âŸ¦ param op âŸ§áµ p v)
    (Î» q y â†’ TË¢-â‰¤t â‰¤-refl (k (â‰¤-trans (+-monoË¡-â‰¤ (op-time op) p) q) y)) q

---- monotonicity wrt time-gradings

TË¢-â‰¤Ï„ : âˆ€ {A Ï„ Ï„' t} â†’ Ï„ â‰¤ Ï„' â†’ TË¢ A Ï„ t â†’ TË¢ A Ï„' t
TË¢-â‰¤Ï„ {(tset A Af)} p (leaf v) = leaf (Af (+-monoË¡-â‰¤ _ p) v)
TË¢-â‰¤Ï„ {(tset A Af)} p (node op v k q) =
  node
    op v
    (Î» r y â†’ TË¢-â‰¤Ï„ (projâ‚‚ (projâ‚‚ (nâ‰¡m+kâ‰¤n' (trans q (+-comm (op-time op) _)) p))) (k r y))
    (trans (projâ‚ (projâ‚‚ (nâ‰¡m+kâ‰¤n' (trans q (+-comm (op-time op) _)) p))) (+-comm _ (op-time op)))

---- functorial action on â†’áµ—

TË¢á¶  : âˆ€ {A B Ï„} â†’ A â†’áµ— B â†’ {t : Time} â†’ TË¢ A Ï„ t â†’ TË¢ B Ï„ t
TË¢á¶  (tset-map f) (leaf a)   =
  leaf (f a)
TË¢á¶  (tset-map f) (node op v k q) =
  node op v (Î» p y â†’ TË¢á¶  (tset-map f) (k p y)) q

---- packaging it all up into a functor on TSet

Táµ’ : TSet â†’ Time â†’ TSet
Táµ’ A Ï„ = tset (Î» t â†’ TË¢ A Ï„ t) TË¢-â‰¤t

Tá¶  : âˆ€ {A B Ï„} â†’ A â†’áµ— B â†’ Táµ’ A Ï„ â†’áµ— Táµ’ B Ï„
Tá¶  f = tset-map (TË¢á¶  f)

T-â‰¤Ï„ : âˆ€ {A Ï„ Ï„'} â†’ Ï„ â‰¤ Ï„' â†’ Táµ’ A Ï„ â†’áµ— Táµ’ A Ï„'
T-â‰¤Ï„ p = tset-map (TË¢-â‰¤Ï„ p)

---- unit of the graded monad

Î·áµ€ : âˆ€ {A} â†’ A â†’áµ— Táµ’ A 0
Î·áµ€ = tset-map (Î» v â†’ leaf v)

---- multiplication of the graded monad

TË¢-move-+ : âˆ€ {A Ï„ Ï„' t} â†’ TË¢ A Ï„ (Ï„' + t) â†’ TË¢ A (Ï„' + Ï„) t
TË¢-move-+ {(tset A Af)} {Ï„} {Ï„'} {t} (leaf v) =
  leaf (Af (â‰¤-reflexive (trans (sym (+-assoc Ï„ Ï„' t)) (cong (_+ t) (+-comm Ï„ Ï„')))) v)
TË¢-move-+ {(tset A Af)} {Ï„} {Ï„'} {t} (node {Ï„ = Ï„''} op v k q) =
  node op
    (âŸ¦âŸ§áµ-constant (param op) (Ï„' + t) t v)  -- can't use monotonicity of the parameter type
    (Î» { {t'} r y â†’ TË¢-move-+ (k (â‰¤-trans (â‰¤-reflexive (+-assoc Ï„' t (op-time op))) (+-monoÊ³-â‰¤ Ï„' r))
                                 (monotone âŸ¦ arity op âŸ§áµ (mâ‰¤n+m t' Ï„') y)) })  -- could also have used âŸ¦âŸ§áµ-constant
    (trans
      (trans
        (cong (Ï„' +_) q)
        (sym (+-assoc Ï„' (op-time op) Ï„'')))
      (trans
        (cong (_+ Ï„'') (+-comm Ï„' (op-time op)))
        (+-assoc (op-time op) Ï„' Ï„'')))


Î¼Ë¢ : âˆ€ {A Ï„ Ï„'} â†’ {t : Time} â†’ carrier (Táµ’ (Táµ’ A Ï„') Ï„) t â†’ carrier (Táµ’ A (Ï„ + Ï„')) t
Î¼Ë¢ {tset A Af} (leaf c) = TË¢-move-+ c
Î¼Ë¢ (node op v k p) =
  node op v (Î» q y â†’ Î¼Ë¢ (k q y)) (trans (cong (_+ _) p) (+-assoc (op-time op) _ _))

Î¼áµ€ : âˆ€ {A Ï„ Ï„'} â†’ Táµ’ (Táµ’ A Ï„') Ï„ â†’áµ— Táµ’ A (Ï„ + Ï„')
Î¼áµ€ = tset-map Î¼Ë¢

---- strength of the graded monad

---- note: had to mark ÏƒË¢ as terminating because Agda's termination
---- gets confused trying to see see that subtrees modelled as a
---- function are smaller that the given tree (I guess reindexing the
---- non-recursive argument component with Af is at fault for this)

{-# TERMINATING #-}
ÏƒË¢ : âˆ€ {A B Ï„} â†’ {t : Time} â†’ carrier A t Ã— carrier (Táµ’ B Ï„) t â†’ carrier (Táµ’ (A Ã—áµ— B) Ï„) t
ÏƒË¢ {tset A Af} {Ï„ = Ï„} {t = t} (v , leaf w) =
  leaf (Af (mâ‰¤n+m t Ï„) v , w)
ÏƒË¢ {tset A Af} {t = t} (v , node op w k p) =
  node op w (Î» q y â†’ ÏƒË¢ (Af (â‰¤-trans (mâ‰¤m+n t (op-time op)) q) v , k q y)) p

Ïƒáµ€ : âˆ€ {A B Ï„} â†’ A Ã—áµ— Táµ’ B Ï„ â†’áµ— Táµ’ (A Ã—áµ— B) Ï„
Ïƒáµ€ = tset-map ÏƒË¢

---- algebraic operations

opáµ€ : âˆ€ {A Ï„} â†’ (op : Op)
    â†’ âŸ¦ param op âŸ§áµ Ã—áµ— ([ op-time op ]áµ’ (âŸ¦ arity op âŸ§áµ â‡’áµ— Táµ’ A Ï„)) â†’áµ— Táµ’ A (op-time op + Ï„)
opáµ€ op = tset-map (Î» { (v , k) â†’ node op v k refl })

-- Interpretation of value and computation types

mutual

  âŸ¦_âŸ§áµ› : VType â†’ TSet
  âŸ¦ Base B âŸ§áµ›  = BaseTSet B
  âŸ¦ Unit âŸ§áµ›    = ğŸ™áµ—
  âŸ¦ Empty âŸ§áµ›   = ğŸ˜áµ—
  âŸ¦ A â‡’ C âŸ§áµ›   = âŸ¦ A âŸ§áµ› â‡’áµ— âŸ¦ C âŸ§á¶œ
  âŸ¦ [ Ï„ ] A âŸ§áµ› = [ Ï„ ]áµ’ âŸ¦ A âŸ§áµ›

  âŸ¦_âŸ§á¶œ : CType â†’ TSet
  âŸ¦ A â€¼ Ï„ âŸ§á¶œ = Táµ’ âŸ¦ A âŸ§áµ› Ï„

  infix 25 âŸ¦_âŸ§áµ›
  infix 25 âŸ¦_âŸ§á¶œ

-- Relating the interpretation of ground types and ground type to type conversion

âŸ¦âŸ§áµ›-âŸ¦âŸ§áµ : (B : GType) â†’ âŸ¦ type-of-gtype B âŸ§áµ› â†’áµ— âŸ¦ B âŸ§áµ
âŸ¦âŸ§áµ›-âŸ¦âŸ§áµ (Base B) = idáµ—
âŸ¦âŸ§áµ›-âŸ¦âŸ§áµ Unit     = idáµ—
âŸ¦âŸ§áµ›-âŸ¦âŸ§áµ Empty    = idáµ—

âŸ¦âŸ§áµ-âŸ¦âŸ§áµ› : (B : GType) â†’ âŸ¦ B âŸ§áµ â†’áµ— âŸ¦ type-of-gtype B âŸ§áµ›
âŸ¦âŸ§áµ-âŸ¦âŸ§áµ› (Base B) = idáµ—
âŸ¦âŸ§áµ-âŸ¦âŸ§áµ› Unit     = idáµ—
âŸ¦âŸ§áµ-âŸ¦âŸ§áµ› Empty    = idáµ—

-- Interpretation of contexts as environments

âŸ¦_âŸ§áµ‰ : Ctx â†’ TSet
âŸ¦ [] âŸ§áµ‰      = ğŸ™áµ—
âŸ¦ Î“ âˆ·á¶œ A âŸ§áµ‰  = âŸ¦ Î“ âŸ§áµ‰ Ã—áµ— âŸ¦ A âŸ§áµ›
âŸ¦ Î“ âŸ¨ Ï„ âŸ© âŸ§áµ‰ = âŸ¨ Ï„ âŸ©áµ’ âŸ¦ Î“ âŸ§áµ‰

infix 25 âŸ¦_âŸ§áµ‰

-- Total delay of an environment as a single âŸ¨_âŸ© modality

env-delay : âˆ€ {Î“ Î“' Î“''} â†’ Î“' , Î“'' split Î“ â†’ âŸ¦ Î“ âŸ§áµ‰ â†’áµ— âŸ¨ ctx-delay Î“'' âŸ©áµ’ âŸ¦ Î“' âŸ§áµ‰
env-delay split-[]     = Î·
env-delay (split-âˆ·á¶œ p) = env-delay p âˆ˜áµ— fstáµ—
env-delay {Î“' = Î“'} {Î“'' = Î“'' âŸ¨ Ï„ âŸ©} (split-âŸ¨âŸ© p) =
     âŸ¨_âŸ©-â‰¤ {A = âŸ¦ Î“' âŸ§áµ‰} (â‰¤-reflexive (+-comm (ctx-delay Î“'') Ï„))
  âˆ˜áµ— Î¼ {A = âŸ¦ Î“' âŸ§áµ‰}
  âˆ˜áµ— âŸ¨ Ï„ âŸ©á¶  (env-delay p)

-- Projecting a variable out of an environment

env-var : âˆ€ {Î“ A} â†’ A âˆˆ Î“ â†’ âŸ¦ Î“ âŸ§áµ‰ â†’áµ— âŸ¦ A âŸ§áµ›
env-var Hd     = sndáµ—
env-var (Tl x) = env-var x âˆ˜áµ— fstáµ—

-- Interpretation of well-typed value and computation terms

mutual

  âŸ¦_âŸ§áµ›áµ— : âˆ€ {Î“ A} â†’ Î“ âŠ¢Vâ¦‚ A â†’ âŸ¦ Î“ âŸ§áµ‰ â†’áµ— âŸ¦ A âŸ§áµ›
  
  âŸ¦ var x âŸ§áµ›áµ— = env-var x
  
  âŸ¦ const c âŸ§áµ›áµ— = constáµ— c âˆ˜áµ— terminaláµ—
  
  âŸ¦ â‹† âŸ§áµ›áµ— = terminaláµ—
  
  âŸ¦ lam M âŸ§áµ›áµ— = curryáµ— âŸ¦ M âŸ§á¶œáµ—
  
  âŸ¦ box {Ï„ = Ï„} V âŸ§áµ›áµ— = ([ Ï„ ]á¶  âŸ¦ V âŸ§áµ›áµ—) âˆ˜áµ— Î·âŠ£ 

  infix 25 âŸ¦_âŸ§áµ›áµ—


  âŸ¦_âŸ§á¶œáµ— : âˆ€ {Î“ C} â†’ Î“ âŠ¢Câ¦‚ C â†’ âŸ¦ Î“ âŸ§áµ‰ â†’áµ— âŸ¦ C âŸ§á¶œ
  
  âŸ¦ return V âŸ§á¶œáµ— = T-â‰¤Ï„ zâ‰¤n âˆ˜áµ— Î·áµ€ âˆ˜áµ— âŸ¦ V âŸ§áµ›áµ—
  
  âŸ¦ M Í¾ N âŸ§á¶œáµ— = Î¼áµ€ âˆ˜áµ— Tá¶  âŸ¦ N âŸ§á¶œáµ— âˆ˜áµ— Ïƒáµ€ âˆ˜áµ— âŸ¨ idáµ— , âŸ¦ M âŸ§á¶œáµ— âŸ©áµ—
  
  âŸ¦ V Â· W âŸ§á¶œáµ— = appáµ— âˆ˜áµ— âŸ¨ âŸ¦ V âŸ§áµ›áµ— , âŸ¦ W âŸ§áµ›áµ— âŸ©áµ—
  
  âŸ¦ absurd V âŸ§á¶œáµ— = initialáµ— âˆ˜áµ— âŸ¦ V âŸ§áµ›áµ—
  
  âŸ¦ perform op V M âŸ§á¶œáµ— =
     opáµ€ op âˆ˜áµ— âŸ¨ âŸ¦âŸ§áµ›-âŸ¦âŸ§áµ (param op) âˆ˜áµ— âŸ¦ V âŸ§áµ›áµ— ,
                 [ op-time op ]á¶  (curryáµ— (âŸ¦ M âŸ§á¶œáµ— âˆ˜áµ— mapË£áµ— idáµ— (âŸ¦âŸ§áµ-âŸ¦âŸ§áµ› (arity op)))) âˆ˜áµ— Î·âŠ£ âŸ©áµ—
                 
  âŸ¦ unbox {Î“'} {Î“''} {Ï„ = Ï„} {Ï„' = Ï„'} p q V M âŸ§á¶œáµ— =
    âŸ¦ M âŸ§á¶œáµ— âˆ˜áµ— âŸ¨ idáµ— ,
                    ÎµâŠ£
                 âˆ˜áµ— âŸ¨ Ï„ âŸ©á¶  âŸ¦ V âŸ§áµ›áµ—
                 âˆ˜áµ— âŸ¨_âŸ©-â‰¤ {A = âŸ¦ Î“' âŸ§áµ‰} (â‰¤-trans q (â‰¤-reflexive (+-comm Ï„' (ctx-delay Î“''))))
                 âˆ˜áµ— Î¼ {A = âŸ¦ Î“' âŸ§áµ‰}
                 âˆ˜áµ— env-delay p âŸ©áµ—
  
  âŸ¦ coerce p M âŸ§á¶œáµ— = T-â‰¤Ï„ p âˆ˜áµ— âŸ¦ M âŸ§á¶œáµ—

  infix 25 âŸ¦_âŸ§á¶œáµ—
