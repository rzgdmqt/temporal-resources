---------------------------------------------------------
-- Free graded monad generated by algebraic operations --
---------------------------------------------------------

open import Function

open import Data.Empty
open import Data.Product
open import Data.Unit hiding (_â‰¤_)

open import Semantics.TSets
open import Semantics.Modality.Future
open import Semantics.Modality.Past

open import Util.HProp
open import Util.Equality
open import Util.Operations
open import Util.Time

module Semantics.Monad where

-- Interpretation of ground types
---------------------------------

-- Note: To apply Adamek's theorem to construct T, likely
-- want to limit them to finite, countable, etc presheaves

âŸ¦_âŸ§áµ : GType â†’ TSet
âŸ¦ Base B âŸ§áµ   = ConstTSet (BaseSet B)
âŸ¦ Unit âŸ§áµ     = ğŸ™áµ—
âŸ¦ Empty âŸ§áµ    = ğŸ˜áµ—
âŸ¦ [ Ï„ ]áµ A âŸ§áµ = [ Ï„ ]áµ’ âŸ¦ A âŸ§áµ

-- The free graded monad generated by the operations in Op
----------------------------------------------------------

-- Skeletal object mapping

mutual
  
  data TË¢ (A : TSet) : (Ï„ : Time) â†’ (t : Time) â†’ Set where  -- 1st time index (Ï„) is the duration of the computation (its time-grading)
                                                            -- 2nd time index (t) is the corresponding TSets' time-index (presheaf index)
    delay : âˆ€ {Ï„' t}
          â†’ (Ï„ : Time)
          â†’ 0 < Ï„
          â†’ Tá¶œË¢ A Ï„' (t + Ï„)
          â†’ TË¢ A (Ï„ + Ï„') t

    comp  : âˆ€ {Ï„ t}
          â†’ Tá¶œË¢ A Ï„ t
          â†’ TË¢ A Ï„ t

  data Tá¶œË¢ (A : TSet) : (Ï„ : Time) â†’ (t : Time) â†’ Set where  -- 1st time index (Ï„) is the duration of the computation (its time-grading)
                                                             -- 2nd time index (t) is the corresponding TSets' time-index (presheaf index)
    leaf  : âˆ€ {t}
          â†’ carrier A t
          â†’ Tá¶œË¢ A 0 t
     
    node  : âˆ€ {Ï„ t}
          â†’ (op : Op)
          â†’ carrier âŸ¦ param op âŸ§áµ t
          â†’ ({t' : Time} â†’ t + op-time op â‰¤ t'
                         â†’ carrier âŸ¦ arity op âŸ§áµ t'
                         â†’ TË¢ A Ï„ t')
          â†’ Tá¶œË¢ A (op-time op + Ï„) t

-- Monotonicity with respect to the (presheaf) time indices

mutual

  TË¢-â‰¤t : âˆ€ {A Ï„ t t'} â†’ t â‰¤ t' â†’ TË¢ A Ï„ t â†’ TË¢ A Ï„ t'
  
  TË¢-â‰¤t p (delay Ï„ q k) =
    delay Ï„ q (Tá¶œË¢-â‰¤t (+-monoË¡-â‰¤ Ï„ p) k)
  TË¢-â‰¤t p (comp k) =
    comp (Tá¶œË¢-â‰¤t p k)

  Tá¶œË¢-â‰¤t : âˆ€ {A Ï„ t t'} â†’ t â‰¤ t' â†’ Tá¶œË¢ A Ï„ t â†’ Tá¶œË¢ A Ï„ t'
  
  Tá¶œË¢-â‰¤t {A} p (leaf v) =
    leaf (monotone A p v)
  Tá¶œË¢-â‰¤t p (node op v k) =
    node op
      (monotone (âŸ¦ param op âŸ§áµ) p v)
      (Î» {t'} q y â†’ k (â‰¤-trans (+-monoË¡-â‰¤ (op-time op) p) q) y)

  TË¢-â‰¤t-refl : âˆ€ {A Ï„ t} â†’ (c : TË¢ A Ï„ t) â†’ TË¢-â‰¤t â‰¤-refl c â‰¡ c
  
  TË¢-â‰¤t-refl (delay Ï„ q k) =
    cong (delay Ï„ q)
      (trans
        (cong (Î» p â†’ Tá¶œË¢-â‰¤t p k) (â‰¤-irrelevant _ _))
        (Tá¶œË¢-â‰¤t-refl k))
  TË¢-â‰¤t-refl (comp k) =
    cong comp (Tá¶œË¢-â‰¤t-refl k)

  Tá¶œË¢-â‰¤t-refl : âˆ€ {A Ï„ t} â†’ (c : Tá¶œË¢ A Ï„ t) â†’ Tá¶œË¢-â‰¤t â‰¤-refl c â‰¡ c
  
  Tá¶œË¢-â‰¤t-refl {A} (leaf v) =
    cong leaf (monotone-refl A v)
  Tá¶œË¢-â‰¤t-refl (node op v k) =
    congâ‚‚ (node op)
      (monotone-refl âŸ¦ param op âŸ§áµ v)
      (ifun-ext (fun-ext (Î» q â†’ cong k (â‰¤-irrelevant _ _))))

  TË¢-â‰¤t-trans : âˆ€ {A Ï„ t t' t''}
              â†’ (p : t â‰¤ t') â†’ (q : t' â‰¤ t'') â†’ (c : TË¢ A Ï„ t)
              â†’ TË¢-â‰¤t q (TË¢-â‰¤t p c) â‰¡ TË¢-â‰¤t (â‰¤-trans p q) c
              
  TË¢-â‰¤t-trans {A} p q (delay Ï„ r k) =
    cong (delay Ï„ r)
      (trans
        (Tá¶œË¢-â‰¤t-trans (+-monoË¡-â‰¤ Ï„ p) (+-monoË¡-â‰¤ Ï„ q) k)
        (cong (Î» p â†’ Tá¶œË¢-â‰¤t p k) (â‰¤-irrelevant _ _)))
  TË¢-â‰¤t-trans p q (comp k) =
    cong comp (Tá¶œË¢-â‰¤t-trans p q k)

  Tá¶œË¢-â‰¤t-trans : âˆ€ {A Ï„ t t' t''}
               â†’ (p : t â‰¤ t') â†’ (q : t' â‰¤ t'') â†’ (c : Tá¶œË¢ A Ï„ t)
               â†’ Tá¶œË¢-â‰¤t q (Tá¶œË¢-â‰¤t p c) â‰¡ Tá¶œË¢-â‰¤t (â‰¤-trans p q) c

  Tá¶œË¢-â‰¤t-trans {A} p q (leaf v) =
    cong leaf (monotone-trans A p q v)
  Tá¶œË¢-â‰¤t-trans p q (node op v k) =
    congâ‚‚ (node op)
      (monotone-trans âŸ¦ param op âŸ§áµ p q v)
      (ifun-ext (fun-ext (Î» r â†’ cong k (â‰¤-irrelevant _ _))))

-- Functorial action

mutual

  TË¢á¶  : âˆ€ {A B Ï„} â†’ A â†’áµ— B â†’ {t : Time} â†’ TË¢ A Ï„ t â†’ TË¢ B Ï„ t
  
  TË¢á¶  f (delay Ï„ p k) =
    delay Ï„ p (Tá¶œË¢á¶  f k)
  TË¢á¶  f (comp k) =
    comp (Tá¶œË¢á¶  f k)

  Tá¶œË¢á¶  : âˆ€ {A B Ï„} â†’ A â†’áµ— B â†’ {t : Time} â†’ Tá¶œË¢ A Ï„ t â†’ Tá¶œË¢ B Ï„ t
  
  Tá¶œË¢á¶  f (leaf v) =
    leaf (map-carrier f v)
  Tá¶œË¢á¶  f (node op v k) =
    node op v (Î» p y â†’ TË¢á¶  f (k p y))

  TË¢á¶ -nat : âˆ€ {A B Ï„} â†’ (f : A â†’áµ— B) â†’ {t t' : â„•}
          â†’ (p : t â‰¤ t') â†’ (c : TË¢ A Ï„ t)
          â†’ TË¢á¶  f (TË¢-â‰¤t p c) â‰¡ TË¢-â‰¤t p (TË¢á¶  f c)

  TË¢á¶ -nat f p (delay Ï„ q k) =
    cong (delay Ï„ q) (Tá¶œË¢á¶ -nat f (+-monoË¡-â‰¤ Ï„ p) k)
  TË¢á¶ -nat f p (comp k) =
    cong comp (Tá¶œË¢á¶ -nat f p k)

  Tá¶œË¢á¶ -nat : âˆ€ {A B Ï„} â†’ (f : A â†’áµ— B) â†’ {t t' : â„•}
           â†’ (p : t â‰¤ t') â†’ (c : Tá¶œË¢ A Ï„ t)
           â†’ Tá¶œË¢á¶  f (Tá¶œË¢-â‰¤t p c) â‰¡ Tá¶œË¢-â‰¤t p (Tá¶œË¢á¶  f c)

  Tá¶œË¢á¶ -nat f p (leaf v) =
    cong leaf (map-nat f p v)
  Tá¶œË¢á¶ -nat f p (node op v k) =
    congâ‚‚ (node op) refl refl

-- Packaging it all up into a functor on TSet

Táµ’ : TSet â†’ Time â†’ TSet
Táµ’ A Ï„ = tset (TË¢ A Ï„) TË¢-â‰¤t TË¢-â‰¤t-refl TË¢-â‰¤t-trans

Tá¶  : âˆ€ {A B Ï„} â†’ A â†’áµ— B â†’ Táµ’ A Ï„ â†’áµ— Táµ’ B Ï„
Tá¶  f = tset-map (TË¢á¶  f) (TË¢á¶ -nat f)

-- Unit

Î·áµ€ : âˆ€ {A} â†’ A â†’áµ— Táµ’ A 0
Î·áµ€ =
  tset-map
    (Î» v â†’ comp (leaf v))
    (Î» p v â†’ refl)

-- Multiplication

mutual
  Î¼Ë¢ : âˆ€ {A Ï„ Ï„'} â†’ {t : Time}
     â†’ TË¢ (Táµ’ A Ï„') Ï„ t â†’ TË¢ A (Ï„ + Ï„') t

  Î¼Ë¢ {A} {t = t} (delay Ï„ p k) with Î¼á¶œË¢ k
  ... | _ , q , delay {Ï„' = Ï„''} Ï„' r k' =
    subst
      (Î» Ï„ â†’ TË¢ A Ï„ t)
      (trans
        (+-assoc Ï„ _ _)
        (trans
          (cong (Ï„ +_) q)
          (sym (+-assoc Ï„ _ _))))
      (delay (Ï„ + Ï„')
        (â‰¤-trans r (mâ‰¤n+m Ï„' Ï„))
        (subst (Î» t â†’ Tá¶œË¢ A Ï„'' t)
          (+-assoc t _ _) k'))
  ... | _ , refl , comp k' =
    subst (Î» Ï„ â†’ TË¢ A Ï„ t) (sym (+-assoc Ï„ _ _)) (delay Ï„ p k')
  Î¼Ë¢ {A} {Ï„} {Ï„'} {t} (comp k) with Î¼á¶œË¢ k
  ... | _ , p , delay Ï„'' q k' =
    subst (Î» Ï„ â†’ TË¢ A Ï„ t) p (delay Ï„'' q k')
  ... | _ , refl , comp k =
    comp k

  Î¼á¶œË¢ : âˆ€ {A Ï„ Ï„'} â†’ {t : Time}
      â†’ Tá¶œË¢ (Táµ’ A Ï„') Ï„ t â†’ Î£[ Ï„'' âˆˆ Time ] (Ï„'' â‰¡ Ï„ + Ï„' Ã— TË¢ A Ï„'' t)

  Î¼á¶œË¢ (leaf c) = _ , refl , c
  Î¼á¶œË¢ {A = A} {t = t} (node op v k) =
    _ , refl , comp (subst
                      (Î» Ï„ â†’ Tá¶œË¢ A Ï„ t)
                      (sym (+-assoc (op-time op) _ _))
                      (node op v Î» p y â†’ Î¼Ë¢ (k p y)))

  Î¼Ë¢-t-nat : âˆ€ {A Ï„ Ï„' t t'}
           â†’ (p : t â‰¤ t')
           â†’ (c : TË¢ (Táµ’ A Ï„') Ï„ t)
           â†’ Î¼Ë¢ (TË¢-â‰¤t p c) â‰¡ TË¢-â‰¤t p (Î¼Ë¢ c)

  Î¼Ë¢-t-nat p (delay Ï„ q k) = {!!}
  Î¼Ë¢-t-nat p (comp k) = {!!}

  Î¼á¶œË¢-t-nat : âˆ€ {A Ï„ Ï„' t t'}
           â†’ (p : t â‰¤ t')
           â†’ (c : Tá¶œË¢ (Táµ’ A Ï„') Ï„ t)
           â†’ {!!} --Î¼á¶œË¢ (Tá¶œË¢-â‰¤t p c) â‰¡ Tá¶œË¢-â‰¤t p (Î¼á¶œË¢ c)

  Î¼á¶œË¢-t-nat = {!!}









{-
-- TODO: work out all formal details of the corresponding
--       definitions (postulating them below for time being)

postulate

  -- Object-mapping

  Táµ’ : TSet â†’ Time â†’ TSet

  -- Functorial action

  Tá¶  : âˆ€ {A B Ï„} â†’ A â†’áµ— B â†’ Táµ’ A Ï„ â†’áµ— Táµ’ B Ï„

  -- Monotonicity wrt. gradings

  -- Note: This would correspond to syntactic sub-effecting,
  -- but the current language doesn't seem to readily support
  -- it. For example, consider the equation/reduction
  --
  --   coerce (p : 0 â‰¤ Ï„') (return V) Í¾ N ~> coerce ... N[V/x]
  --
  -- where if the LHS is typed according to the obvious
  -- rule, N would be typed in a context `Î“ âŸ¨ Ï„' âŸ© âˆ· A`
  -- but this cannot be turned into a context `Î“ âˆ· A` as
  -- needed in the RHS of the equation/reduction. Instead
  -- it seems to remain the case that one needs to use the
  -- explicit delays instead of sub-effecting coercions.

  -- T-â‰¤Ï„ : âˆ€ {A Ï„ Ï„'} â†’ Ï„ â‰¤ Ï„' â†’ Táµ’ A Ï„ â†’áµ— Táµ’ A Ï„'

  -- Unit

  Î·áµ€ : âˆ€ {A} â†’ A â†’áµ— Táµ’ A 0

  -- Multiplication

  Î¼áµ€ : âˆ€ {A Ï„ Ï„'} â†’ Táµ’ (Táµ’ A Ï„') Ï„ â†’áµ— Táµ’ A (Ï„ + Ï„')

  -- Strength

  stráµ€ : âˆ€ {A B Ï„} â†’ [ Ï„ ]áµ’ A Ã—áµ— Táµ’ B Ï„ â†’áµ— Táµ’ (A Ã—áµ— B) Ï„

  -- Delay operation (T is a kind of a [_]-module)

  T-delay : âˆ€ {A Ï„ Ï„'} â†’ [ Ï„ ]áµ’ (Táµ’ A Ï„') â†’áµ— Táµ’ A (Ï„ + Ï„')

  -- Algebraic operations

  opáµ€ : âˆ€ {A Ï„} â†’ (op : Op)
      â†’ âŸ¦ param op âŸ§áµ Ã—áµ— [ op-time op ]áµ’ (âŸ¦ arity op âŸ§áµ â‡’áµ— Táµ’ A Ï„) â†’áµ— Táµ’ A (op-time op + Ï„)

  -- T-algebra induced by an effect handler

  alg-of-handler : âˆ€ {A Ï„ Ï„'}
                 â†’ Î  Op (Î» op â†’ Î  Time (Î» Ï„'' â†’
                    âŸ¦ param op âŸ§áµ Ã—áµ— ([ op-time op ]áµ’ (âŸ¦ arity op âŸ§áµ â‡’áµ— (Táµ’ A Ï„'')))
                      â‡’áµ— Táµ’ A (op-time op + Ï„'')))
                 â†’áµ— Táµ’ (Táµ’ A Ï„') Ï„ â‡’áµ— (Táµ’ A (Ï„ + Ï„'))


---------------------------------------------------------
---------------------------------------------------------


-- Candidate for object-mapping of the underlying functor

-- Note: organised into two mutually given definitions so
--       as to model the refl/trans rules for delays

mutual
  
  data TË¢ (A : TSet) : (Ï„ : Time) â†’ (t : Time) â†’ Set where  -- 1st time index (Ï„) is the duration of the computation (its time-grading)
                                                            -- 2nd time index (t) is the corresponding TSets' time-index (presheaf index)
    delay : âˆ€ {Ï„' t}
          â†’ (Ï„ : Time)
          â†’ 0 < Ï„
          â†’ Tá¶œË¢ A Ï„' (t + Ï„)
          â†’ TË¢ A (Ï„ + Ï„') t

    comp  : âˆ€ {Ï„ t}
          â†’ Tá¶œË¢ A Ï„ t
          â†’ TË¢ A Ï„ t

  data Tá¶œË¢ (A : TSet) : (Ï„ : Time) â†’ (t : Time) â†’ Set where  -- 1st time index (Ï„) is the duration of the computation (its time-grading)
                                                             -- 2nd time index (t) is the corresponding TSets' time-index (presheaf index)
    leaf  : âˆ€ {t}
          â†’ carrier A t
          â†’ Tá¶œË¢ A 0 t
     
    node  : âˆ€ {Ï„ t}
          â†’ (op : Op)
          â†’ carrier âŸ¦ param op âŸ§áµ t
          â†’ ({t' : Time} â†’ t + op-time op â‰¤ t'
                         â†’ carrier âŸ¦ arity op âŸ§áµ t'
                         â†’ TË¢ A Ï„ t')
          â†’ Tá¶œË¢ A (op-time op + Ï„) t
-}
