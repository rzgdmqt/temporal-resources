---------------------------------------------------------
-- Free graded monad generated by algebraic operations --
---------------------------------------------------------

open import Function

open import Data.Empty
open import Data.Product
open import Data.Unit hiding (_â‰¤_)

open import Semantics.TSets
open import Semantics.Modality.Future
open import Semantics.Modality.Past

open import Util.HProp
open import Util.Equality
open import Util.Operations
open import Util.Time

module Semantics.Monad where

-- Interpretation of ground types

-- Note: To apply Adamek's theorem to construct T, likely
-- want to limit them to finite, countable, etc presheaves

âŸ¦_âŸ§áµ : GType â†’ TSet
âŸ¦ Base B âŸ§áµ   = ConstTSet (BaseSet B)
âŸ¦ Unit âŸ§áµ     = ğŸ™áµ—
âŸ¦ Empty âŸ§áµ    = ğŸ˜áµ—
âŸ¦ [ Ï„ ]áµ A âŸ§áµ = [ Ï„ ]áµ’ âŸ¦ A âŸ§áµ

-- The free graded monad generated by the operations in Op

-- TODO: work out all formal details of the corresponding
--       definitions (postulating them below for time being)

postulate

  -- Object-mapping

  Táµ’ : TSet â†’ Time â†’ TSet

  -- Functorial action

  Tá¶  : âˆ€ {A B Ï„} â†’ A â†’áµ— B â†’ Táµ’ A Ï„ â†’áµ— Táµ’ B Ï„

  -- Monotonicity wrt. gradings

  -- Note: This would correspond to syntactic sub-effecting,
  -- but the current language doesn't seem to readily support
  -- it. For example, consider the equation/reduction
  --
  --   coerce (p : 0 â‰¤ Ï„') (return V) Í¾ N ~> coerce ... N[V/x]
  --
  -- where if the LHS is typed according to the obvious
  -- rule, N would be typed in a context `Î“ âŸ¨ Ï„' âŸ© âˆ· A`
  -- but this cannot be turned into a context `Î“ âˆ· A` as
  -- needed in the RHS of the equation/reduction. Instead
  -- it seems to remain the case that one needs to use the
  -- explicit delays instead of sub-effecting coercions.

  -- T-â‰¤Ï„ : âˆ€ {A Ï„ Ï„'} â†’ Ï„ â‰¤ Ï„' â†’ Táµ’ A Ï„ â†’áµ— Táµ’ A Ï„'

  -- Unit

  Î·áµ€ : âˆ€ {A} â†’ A â†’áµ— Táµ’ A 0

  -- Multiplication

  Î¼áµ€ : âˆ€ {A Ï„ Ï„'} â†’ Táµ’ (Táµ’ A Ï„') Ï„ â†’áµ— Táµ’ A (Ï„ + Ï„')

  -- Strength

  stráµ€ : âˆ€ {A B Ï„} â†’ [ Ï„ ]áµ’ A Ã—áµ— Táµ’ B Ï„ â†’áµ— Táµ’ (A Ã—áµ— B) Ï„

  -- Delay operation (T is a kind of a [_]-module)

  T-delay : âˆ€ {A Ï„ Ï„'} â†’ [ Ï„ ]áµ’ (Táµ’ A Ï„') â†’áµ— Táµ’ A (Ï„ + Ï„')

  -- Algebraic operations

  opáµ€ : âˆ€ {A Ï„} â†’ (op : Op)
      â†’ âŸ¦ param op âŸ§áµ Ã—áµ— [ op-time op ]áµ’ (âŸ¦ arity op âŸ§áµ â‡’áµ— Táµ’ A Ï„) â†’áµ— Táµ’ A (op-time op + Ï„)

  -- T-algebra induced by an effect handler

  alg-of-handler : âˆ€ {A Ï„ Ï„'}
                 â†’ Î  Op (Î» op â†’ Î  Time (Î» Ï„'' â†’
                    âŸ¦ param op âŸ§áµ Ã—áµ— ([ op-time op ]áµ’ (âŸ¦ arity op âŸ§áµ â‡’áµ— (Táµ’ A Ï„'')))
                      â‡’áµ— Táµ’ A (op-time op + Ï„'')))
                 â†’áµ— Táµ’ (Táµ’ A Ï„') Ï„ â‡’áµ— (Táµ’ A (Ï„ + Ï„'))


---------------------------------------------------------
---------------------------------------------------------


-- Candidate for object-mapping of the underlying functor

-- Note: organised into two mutually given definitions so
--       as to model the refl/trans rules for delays

mutual
  
  data TË¢ (A : TSet) : (Ï„ : Time) â†’ (t : Time) â†’ Set where  -- 1st time index (Ï„) is the duration of the computation (its time-grading)
                                                            -- 2nd time index (t) is the corresponding TSets' time-index (presheaf index)
    delay : âˆ€ {Ï„' t}
          â†’ (Ï„ : Time)
          â†’ 0 < Ï„
          â†’ Tá¶œË¢ A Ï„' (t + Ï„)
          â†’ TË¢ A (Ï„ + Ï„') t

    comp  : âˆ€ {Ï„ t}
          â†’ Tá¶œË¢ A Ï„ t
          â†’ TË¢ A Ï„ t

  data Tá¶œË¢ (A : TSet) : (Ï„ : Time) â†’ (t : Time) â†’ Set where  -- 1st time index (Ï„) is the duration of the computation (its time-grading)
                                                             -- 2nd time index (t) is the corresponding TSets' time-index (presheaf index)
    leaf  : âˆ€ {t}
          â†’ carrier A t
          â†’ Tá¶œË¢ A 0 t
     
    node  : âˆ€ {Ï„ t}
          â†’ (op : Op)
          â†’ carrier âŸ¦ param op âŸ§áµ t
          â†’ ({t' : Time} â†’ t + op-time op â‰¤ t'
                         â†’ carrier âŸ¦ arity op âŸ§áµ t'
                         â†’ TË¢ A Ï„ t')
          â†’ Tá¶œË¢ A (op-time op + Ï„) t
