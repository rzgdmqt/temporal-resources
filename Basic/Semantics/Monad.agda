---------------------------------------------------------
-- Free graded monad generated by algebraic operations --
---------------------------------------------------------

-- Note: A version of the monad that is not quotioned by
--       the delay equations (identity and composition)

open import Function

open import Data.Empty
open import Data.Product
open import Data.Unit hiding (_â‰¤_)

open import Semantics.TSets
open import Semantics.Modality.Future
open import Semantics.Modality.Past

open import Util.HProp
open import Util.Equality
open import Util.Operations
open import Util.Time

module Semantics.Monad where

-- Interpretation of ground types
---------------------------------

âŸ¦_âŸ§áµ : GType â†’ TSet
âŸ¦ Base B âŸ§áµ   = ConstTSet (BaseSet B)
âŸ¦ Unit âŸ§áµ     = ğŸ™áµ—
âŸ¦ Empty âŸ§áµ    = ğŸ˜áµ—
âŸ¦ [ Ï„ ]áµ A âŸ§áµ = [ Ï„ ]áµ’ âŸ¦ A âŸ§áµ


-- The free graded monad generated by the operations in Op
----------------------------------------------------------

-- Object mapping and time-monotonicity

mutual

  data TË¢ (A : TSet) : (Ï„ : Time) â†’ (t : Time) â†’ Set where

    leaf  : âˆ€ {t}
          â†’ carrier A t
          â†’ TË¢ A 0 t
       
    node  : âˆ€ {Ï„ t}
          â†’ (op : Op)
          â†’ carrier âŸ¦ param op âŸ§áµ t
          â†’ (k : {t' : Time} â†’ t + op-time op â‰¤ t'
                             â†’ carrier âŸ¦ arity op âŸ§áµ t'
                             â†’ TË¢ A Ï„ t')
          â†’ ({t' t'' : Time} â†’ (p : t' â‰¤ t'')                                       -- time-naturality of continuation
                             â†’ (q : t + op-time op â‰¤ t')
                             â†’ (y : carrier âŸ¦ arity op âŸ§áµ t')
                             â†’ k (â‰¤-trans q p) (monotone (âŸ¦ arity op âŸ§áµ) p y)
                             â‰¡ TË¢-â‰¤t p (k q y))
          â†’ TË¢ A (op-time op + Ï„) t
     
    delay : âˆ€ {Ï„' t}
          â†’ (Ï„ : Time)
          â†’ TË¢ A Ï„' (t + Ï„)
          â†’ TË¢ A (Ï„ + Ï„') t


  TË¢-â‰¤t : âˆ€ {A Ï„ t t'} â†’ t â‰¤ t' â†’ TË¢ A Ï„ t â†’ TË¢ A Ï„ t'
  TË¢-â‰¤t {A} p (leaf v) =
    leaf (monotone A p v)
  TË¢-â‰¤t p (node op v k k-nat) =
    node op
      (monotone (âŸ¦ param op âŸ§áµ) p v)
      (Î» q y â†’ k (â‰¤-trans (+-monoË¡-â‰¤ (op-time op) p) q) y)
      (Î» p q y â†’
        trans
          (cong (Î» q â†’ k q (monotone âŸ¦ arity op âŸ§áµ p y)) (â‰¤-irrelevant _ _))
          (k-nat _ _ y))
  TË¢-â‰¤t p (delay Ï„ k) =
    delay Ï„ (TË¢-â‰¤t (+-monoË¡-â‰¤ Ï„ p) k)


-- Reflexivity and transitivity of time-monotonicity

TË¢-â‰¤t-refl : âˆ€ {A Ï„ t} â†’ (c : TË¢ A Ï„ t) â†’ TË¢-â‰¤t â‰¤-refl c â‰¡ c
TË¢-â‰¤t-refl {A} (leaf v) =
  cong leaf (monotone-refl A v)
TË¢-â‰¤t-refl {A = A} {t = t} (node {Ï„ = Ï„} op v k k-nat) =
  dcongâ‚ƒ (node op)
    (monotone-refl âŸ¦ param op âŸ§áµ v)
    (ifun-ext (fun-ext (Î» p â†’ fun-ext (Î» y â†’
      trans
        (cong (Î» (k : {t' : Time} â†’ t + op-time op â‰¤ t' â†’ carrier âŸ¦ arity op âŸ§áµ t' â†’ TË¢ A Ï„ t') â†’ k p y)
          {subst (Î» _ â†’ {t' : Time} â†’ t + op-time op â‰¤ t' â†’ carrier âŸ¦ arity op âŸ§áµ t' â†’ TË¢ A Ï„ t')
              (monotone-refl âŸ¦ param op âŸ§áµ v)
              (Î» q â†’ k (â‰¤-trans (+-monoË¡-â‰¤ (op-time op) â‰¤-refl) q))}
          (subst-const _ (monotone-refl âŸ¦ param op âŸ§áµ v) _))
        (cong (Î» p â†’ k p y) (â‰¤-irrelevant _ _))))))
    (ifun-ext (ifun-ext (fun-ext (Î» p â†’ fun-ext (Î» q â†’ fun-ext (Î» y â†’ uip))))))
TË¢-â‰¤t-refl (delay Ï„ k) =
  cong (delay Ï„)
    (trans
      (cong (Î» p â†’ TË¢-â‰¤t p k) (â‰¤-irrelevant _ _))
      (TË¢-â‰¤t-refl k))

TË¢-â‰¤t-trans : âˆ€ {A Ï„ t t' t''}
            â†’ (p : t â‰¤ t') â†’ (q : t' â‰¤ t'') â†’ (c : TË¢ A Ï„ t)
            â†’ TË¢-â‰¤t q (TË¢-â‰¤t p c) â‰¡ TË¢-â‰¤t (â‰¤-trans p q) c
TË¢-â‰¤t-trans {A} p q (leaf v) =
  cong leaf (monotone-trans A p q v)
TË¢-â‰¤t-trans {A = A} {t'' = t''} p q (node {Ï„ = Ï„} op v k k-nat) =
  dcongâ‚ƒ (node op)
    (monotone-trans (âŸ¦ param op âŸ§áµ) p q v)
    (ifun-ext (fun-ext (Î» r â†’ fun-ext (Î» y â†’
      trans
        (cong (Î» (k : {t''' : Time} â†’ t'' + op-time op â‰¤ t''' â†’ carrier âŸ¦ arity op âŸ§áµ t''' â†’ TË¢ A Ï„ t''') â†’ k r y)
          {subst
            (Î» _ â†’ {t' = t''' : Time} â†’ t'' + op-time op â‰¤ t''' â†’ carrier âŸ¦ arity op âŸ§áµ t''' â†’ TË¢ A Ï„ t''')
            (monotone-trans âŸ¦ param op âŸ§áµ p q v)
            (Î» r â†’ k (â‰¤-trans (+-monoË¡-â‰¤ (op-time op) p) (â‰¤-trans (+-monoË¡-â‰¤ (op-time op) q) r)))}
          (subst-const _ (monotone-trans âŸ¦ param op âŸ§áµ p q v) _))
        (cong (Î» p â†’ k p y) (â‰¤-irrelevant _ _))))))
    (ifun-ext (ifun-ext (fun-ext (Î» p â†’ fun-ext (Î» q â†’ fun-ext (Î» y â†’ uip))))))
TË¢-â‰¤t-trans p q (delay Ï„ k) =
  cong (delay Ï„)
    (trans
      (TË¢-â‰¤t-trans (+-monoË¡-â‰¤ Ï„ p) (+-monoË¡-â‰¤ Ï„ q) k)
      (cong (Î» p â†’ TË¢-â‰¤t p k) (â‰¤-irrelevant _ _)))


-- "subst" for time-gradings

Ï„-subst : âˆ€ {A Ï„ Ï„' t}
        â†’ Ï„ â‰¡ Ï„'
        â†’ TË¢ A Ï„ t
        â†’ TË¢ A Ï„' t
Ï„-subst refl c = c

Ï„-subst-â‰¤t : âˆ€ {A Ï„ Ï„' t t'}
           â†’ (p : Ï„ â‰¡ Ï„')
           â†’ (q : t â‰¤ t')
           â†’ (c : TË¢ A Ï„ t)
           â†’ TË¢-â‰¤t q (Ï„-subst p c) â‰¡ Ï„-subst p (TË¢-â‰¤t q c)
Ï„-subst-â‰¤t refl q c = refl


-- Functorial action (TODO: prove identity and composition laws)

mutual

  -- TODO: investigate how to convince Agda's termination checker;
  --       the "suspicious" recursive occurrences of `TË¢á¶ ` are in 
  --       types (but still applied to the continuation `k`);
  --       so maybe it is enough to index the trees by their height
  --
  --       same also applies for definitions below

  {-# TERMINATING #-}

  TË¢á¶  : âˆ€ {A B Ï„} â†’ A â†’áµ— B â†’ {t : Time} â†’ TË¢ A Ï„ t â†’ TË¢ B Ï„ t
  TË¢á¶  f (leaf v) =
    leaf (map-carrier f v)
  TË¢á¶  f (node op v k k-nat) =
    node op v
      (Î» p y â†’ TË¢á¶  f (k p y))
      (Î» p q y â†’
        trans
          (cong (TË¢á¶  f) (k-nat p q y))
          (TË¢á¶ -â‰¤t-nat f p (k q y)))    
  TË¢á¶  f (delay Ï„ k) =
    delay Ï„ (TË¢á¶  f k)

  TË¢á¶ -â‰¤t-nat : âˆ€ {A B Ï„} â†’ (f : A â†’áµ— B) â†’ {t t' : â„•}
             â†’ (p : t â‰¤ t') â†’ (c : TË¢ A Ï„ t)
             â†’ TË¢á¶  f (TË¢-â‰¤t p c) â‰¡ TË¢-â‰¤t p (TË¢á¶  f c)
  TË¢á¶ -â‰¤t-nat f p (leaf v) =
    cong leaf (map-nat f p v)
  TË¢á¶ -â‰¤t-nat f p (node op v k k-nat) =
    dcongâ‚ƒ (node op)
      refl
      refl
      (ifun-ext (ifun-ext (fun-ext (Î» p â†’ fun-ext (Î» q â†’ fun-ext (Î» y â†’ uip))))))
  TË¢á¶ -â‰¤t-nat f p (delay Ï„ k) =
    cong (delay Ï„) (TË¢á¶ -â‰¤t-nat f (+-monoË¡-â‰¤ Ï„ p) k)


-- Packaging it all up into a functor on TSet

abstract 
  Táµ’ : TSet â†’ Time â†’ TSet
  Táµ’ A Ï„ = tset (TË¢ A Ï„) TË¢-â‰¤t TË¢-â‰¤t-refl TË¢-â‰¤t-trans

  Tá¶  : âˆ€ {A B Ï„} â†’ A â†’áµ— B â†’ Táµ’ A Ï„ â†’áµ— Táµ’ B Ï„
  Tá¶  f = tset-map (TË¢á¶  f) (TË¢á¶ -â‰¤t-nat f)


-- Unit (TODO: prove naturality and laws)

abstract
  Î·áµ€ : âˆ€ {A} â†’ A â†’áµ— Táµ’ A 0
  Î·áµ€ =
    tset-map
      (Î» v â†’ leaf v)
      (Î» p v â†’ refl)


-- Multiplication (TODO: prove naturality and laws)

mutual abstract

  {-# TERMINATING #-}

  Î¼Ë¢ : âˆ€ {A Ï„ Ï„'} â†’ {t : Time}
     â†’ TË¢ (Táµ’ A Ï„') Ï„ t â†’ TË¢ A (Ï„ + Ï„') t
  Î¼Ë¢ (leaf c) =
    c
  Î¼Ë¢ (node op v k k-nat) =
    Ï„-subst
      (sym (+-assoc (op-time op) _ _))
      (node op v
        (Î» p y â†’ Î¼Ë¢ (k p y))
        (Î» p q y â†’
          trans
            (cong Î¼Ë¢ (k-nat p q y))
            (Î¼Ë¢-â‰¤t-nat p (k q y))))
  Î¼Ë¢ (delay Ï„ k) =
    Ï„-subst (sym (+-assoc Ï„ _ _)) (delay Ï„ (Î¼Ë¢ k))

  Î¼Ë¢-â‰¤t-nat : âˆ€ {A Ï„ Ï„'} â†’ {t t' : â„•}
          â†’ (p : t â‰¤ t')
          â†’ (c : TË¢ (Táµ’ A Ï„') Ï„ t)
          â†’ Î¼Ë¢ (TË¢-â‰¤t p c) â‰¡ TË¢-â‰¤t p (Î¼Ë¢ c)
  Î¼Ë¢-â‰¤t-nat p (leaf v) =
    refl
  Î¼Ë¢-â‰¤t-nat p (node op v k k-nat) =
    trans
      (cong (Ï„-subst (sym (+-assoc (op-time op) _ _)))
        (dcongâ‚‚ (node op (monotone âŸ¦ param op âŸ§áµ p v))
          refl
          (ifun-ext (ifun-ext (fun-ext (Î» q â†’ fun-ext (Î» r â†’ fun-ext (Î» y â†’ uip))))))))
      (sym (Ï„-subst-â‰¤t (sym (+-assoc (op-time op) _ _)) p _))
  Î¼Ë¢-â‰¤t-nat p (delay Ï„ k) =
    trans
      (cong
        (Ï„-subst (sym (+-assoc Ï„ _ _)))
        (cong (delay Ï„) (Î¼Ë¢-â‰¤t-nat (+-monoË¡-â‰¤ Ï„ p) k)))
      (sym (Ï„-subst-â‰¤t (sym (+-assoc Ï„ _ _)) p (delay Ï„ (Î¼Ë¢ k))))

abstract
  Î¼áµ€ : âˆ€ {A Ï„ Ï„'}
     â†’ Táµ’ (Táµ’ A Ï„') Ï„ â†’áµ— Táµ’ A (Ï„ + Ï„')
  Î¼áµ€ = tset-map Î¼Ë¢ Î¼Ë¢-â‰¤t-nat


-- Strength (TODO: prove naturality and laws)

mutual

  {-# TERMINATING #-}

  strË¢ : âˆ€ {A B Ï„ Ï„' t}
       â†’ carrier ([ Ï„ ]áµ’ (âŸ¨ Ï„' âŸ©áµ’ A)) t
       â†’ TË¢ B Ï„ t
       â†’ TË¢ (âŸ¨ Ï„' âŸ©áµ’ A Ã—áµ— B) Ï„ t
  strË¢ {A} {B} {Ï„' = Ï„'} {t} v (leaf w) =
    leaf
      (pack-Ã—áµ—
        ((â‰¤-trans (projâ‚ v) (â‰¤-reflexive (+-identityÊ³ _)) ,
           monotone A
             (â‰¤-reflexive (cong (_âˆ¸ Ï„') (+-identityÊ³ _)))
             (projâ‚‚ v)) ,
         w))
  strË¢ {A} {B} {_} {Ï„'} {t} v (node op w k k-nat) =
    node op w
      (Î» p y â†’
        strË¢ {A} {B}
          ((monotone (âŸ¨ Ï„' âŸ©áµ’ A)
             (â‰¤-trans
               (â‰¤-reflexive (sym (+-assoc t _ _)))
               (+-monoË¡-â‰¤ _ p))
             v))
          (k p y))
      (Î» p q y â†’
        trans
          (congâ‚‚ strË¢
            (congâ‚‚ _,_
              (â‰¤-irrelevant _ _)
              (trans
                (cong (Î» p â†’ monotone A p (projâ‚‚ v))
                  (â‰¤-irrelevant _ _))
                (sym
                  (monotone-trans A _
                    (âˆ¸-monoË¡-â‰¤ Ï„' (+-monoË¡-â‰¤ _ p))
                    (projâ‚‚ v)))))
            (k-nat p q y))
          (strË¢-â‰¤t-nat p _ (k q y)))
  strË¢ {A} {B} {_} {Ï„'} {t} v (delay Ï„ k) =
    delay Ï„
      (strË¢ {A} {B}
        (monotone (âŸ¨ Ï„' âŸ©áµ’ A) (â‰¤-reflexive (sym (+-assoc t _ _))) v)
        k)
     
  strË¢-â‰¤t-nat : âˆ€ {A B Ï„ Ï„'} â†’ {t t' : â„•} â†’ (p : t â‰¤ t')
              â†’ (v : carrier ([ Ï„ ]áµ’ (âŸ¨ Ï„' âŸ©áµ’ A)) t)
              â†’ (c : TË¢ B Ï„ t)
              â†’ strË¢ {A = A} {B = B}
                  (monotone ([ Ï„ ]áµ’ (âŸ¨ Ï„' âŸ©áµ’ A)) p v)
                  (TË¢-â‰¤t p c)
              â‰¡ TË¢-â‰¤t p (strË¢ {A = A} {B = B} v c)
  strË¢-â‰¤t-nat {A} {B} p v (leaf w) =
    cong leaf
      (trans
        (cong pack-Ã—áµ—
          (cong (_, monotone B p w)
            (congâ‚‚ _,_
              (â‰¤-irrelevant _ _)
              (trans
                (trans
                  (monotone-trans A _ _ (projâ‚‚ v))
                  (cong (Î» p â†’ monotone A p (projâ‚‚ v)) (â‰¤-irrelevant _ _)))
                (sym (monotone-trans A _ _ (projâ‚‚ v)))))))
        (sym (pack-Ã—áµ—-monotone p _)))
  strË¢-â‰¤t-nat {A} {B} p v (node op w k k-nat) =
    dcongâ‚‚ (node op (monotone âŸ¦ param op âŸ§áµ p w))
      (ifun-ext (fun-ext (Î» q â†’ fun-ext (Î» y â†’
        cong (Î» v â†’ strË¢ {A} {B} v (k (â‰¤-trans (+-monoË¡-â‰¤ (op-time op) p) q) y))
          (congâ‚‚ _,_
            (â‰¤-irrelevant _ _)
            (trans
              (monotone-trans A _ _ (projâ‚‚ v))
              (cong (Î» p â†’ monotone A p (projâ‚‚ v)) (â‰¤-irrelevant _ _))))))))
      (ifun-ext (ifun-ext (fun-ext (Î» q â†’ fun-ext (Î» r â†’ fun-ext (Î» y â†’ uip))))))
  strË¢-â‰¤t-nat {A} {B} {_} {Ï„'} {t} {t'} p v (delay Ï„ k) =
    cong (delay Ï„)
      (trans
        (cong (Î» v â†’ strË¢ {A} {B} v (TË¢-â‰¤t (+-monoË¡-â‰¤ _ p) k))
          (congâ‚‚ _,_
            (â‰¤-irrelevant _ _)
            (trans
              (monotone-trans A _ _ (projâ‚‚ v))
              (trans
                (cong (Î» p â†’ monotone A p (projâ‚‚ v)) (â‰¤-irrelevant _ _))
                (sym (monotone-trans A _ _ (projâ‚‚ v)))))))
        (strË¢-â‰¤t-nat
          (+-monoË¡-â‰¤ Ï„ p)
          (monotone (âŸ¨ Ï„' âŸ©áµ’ A) (â‰¤-reflexive (sym (+-assoc t _ _))) v)
          k))

abstract
  stráµ€ : âˆ€ {A B Ï„ Ï„'}
       â†’ [ Ï„ ]áµ’ (âŸ¨ Ï„' âŸ©áµ’ A) Ã—áµ— Táµ’ B Ï„ â†’áµ— Táµ’ (âŸ¨ Ï„' âŸ©áµ’ A Ã—áµ— B) Ï„
  stráµ€ {A} {B} {Ï„} {Ï„'} =
    tset-map
      (Î» vc â†’ strË¢ {A} {B} (projâ‚ (unpack-Ã—áµ— vc)) (projâ‚‚ (unpack-Ã—áµ— vc)))
      (Î» p vc â†’ trans
        (congâ‚‚ strË¢
          (sym (cong projâ‚ (unpack-Ã—áµ—-monotone {[ Ï„ ]áµ’ (âŸ¨ Ï„' âŸ©áµ’ A)} {Táµ’ B Ï„} p vc)))
          (sym (cong projâ‚‚ (unpack-Ã—áµ—-monotone {[ Ï„ ]áµ’ (âŸ¨ Ï„' âŸ©áµ’ A)} {Táµ’ B Ï„} p vc))))
        (strË¢-â‰¤t-nat p _ _))


-- Delay operation (T is a kind of a [_]-module)

abstract
  delayáµ€ : âˆ€ {A} (Ï„ : Time) {Ï„'} â†’ [ Ï„ ]áµ’ (Táµ’ A Ï„') â†’áµ— Táµ’ A (Ï„ + Ï„')
  delayáµ€ Ï„ =
    tset-map
      (delay Ï„)
      (Î» p c â†’ refl)


-- Algebraic operations

abstract
  opáµ€ : âˆ€ {A Ï„} â†’ (op : Op)
      â†’ âŸ¦ param op âŸ§áµ Ã—áµ— [ op-time op ]áµ’ (âŸ¦ arity op âŸ§áµ â‡’áµ— Táµ’ A Ï„) â†’áµ— Táµ’ A (op-time op + Ï„)
  opáµ€ {A} {Ï„} op =
    tset-map
      (Î» {t} vk â†’
        node op
          (projâ‚ (unpack-Ã—áµ— vk))
          (Î» p y â†’
            map-carrier
              (unpack-â‡’áµ— (projâ‚‚ (unpack-Ã—áµ— vk)))
              (pack-Ã—áµ— (pack-homáµ’ (t + op-time op) p , y)))
          (Î» p q y â†’
            trans
              (cong (map-carrier (unpack-â‡’áµ— (projâ‚‚ (unpack-Ã—áµ— vk))))
                (trans
                  (cong pack-Ã—áµ—
                    (cong (_, monotone âŸ¦ arity op âŸ§áµ p y)
                      (sym (pack-homáµ’-monotone _ _))))
                  (sym (pack-Ã—áµ—-monotone _ _))))
              (map-nat (unpack-â‡’áµ— (projâ‚‚ (unpack-Ã—áµ— vk))) _ _)))
      (Î» {t} {t'} p k â†’
        dcongâ‚ƒ (node op)
          (sym (cong projâ‚ (unpack-Ã—áµ—-monotone _ k)))
          (ifun-ext (fun-ext (Î» q â†’ fun-ext (Î» y â†’
            trans
              (cong (Î» (k : {t' : Time} â†’ _ + op-time op â‰¤ t' â†’ carrier âŸ¦ arity op âŸ§áµ t' â†’ TË¢ A _ t') â†’ k q y)
                (subst-const _ (sym (cong projâ‚ (unpack-Ã—áµ—-monotone p k))) _))
              {!!}))))
          (ifun-ext (ifun-ext (fun-ext (Î» q â†’ fun-ext (Î» r â†’ fun-ext (Î» y â†’ uip)))))))


-- {(Î» pâ‚ yâ‚ â†’ map-carrier (unpack-â‡’áµ— (projâ‚‚ (unpack-Ã—áµ— (monotone (âŸ¦ param op âŸ§áµ Ã—áµ— [ op-time op ]áµ’ (âŸ¦ arity op âŸ§áµ â‡’áµ— Táµ’ A _)) p k)))) (pack-Ã—áµ— (pack-homáµ’ (_ + op-time op) pâ‚ , yâ‚)))}


-- Effect handling / free algebras

mutual abstract

  {-# TERMINATING #-}

  handleË¢ : âˆ€ {A B Ï„ Ï„' t}
          â†’ ((op : Op) â†’ (Ï„'' : Time) â†’
               âŸ¦ param op âŸ§áµ Ã—áµ— ([ op-time op ]áµ’ (âŸ¦ arity op âŸ§áµ â‡’áµ— Táµ’ B Ï„'')) â†’áµ— Táµ’ B (op-time op + Ï„''))
          â†’ A â†’áµ— Táµ’ B Ï„'
          â†’ TË¢ A Ï„ t
          â†’ TË¢ B (Ï„ + Ï„') t
  handleË¢ h f (leaf v) =
    map-carrier f v
  handleË¢ {A} {B} {t = t} h f (node op v k k-nat) =
    Ï„-subst
      (sym (+-assoc (op-time op) _ _))
      (map-carrier (h op _)
        (pack-Ã—áµ— (v ,
          pack-â‡’áµ—
            (tset-map
              (Î» py â†’
                handleË¢ h f
                  (k (unpack-homáµ’ (t + op-time op) (projâ‚ (unpack-Ã—áµ— py)))
                     (projâ‚‚ (unpack-Ã—áµ— py))))
              (Î» p qy â†’ trans
                (cong
                  (handleË¢ {A} {B} h f)
                  {k (unpack-homáµ’ (t + op-time op)
                       (projâ‚ (unpack-Ã—áµ— (monotone (homáµ’ (t + op-time op) Ã—áµ— âŸ¦ arity op âŸ§áµ) p qy))))
                     (projâ‚‚ (unpack-Ã—áµ— (monotone (homáµ’ (t + op-time op) Ã—áµ— âŸ¦ arity op âŸ§áµ) p qy)))}
                  {TË¢-â‰¤t p (k (unpack-homáµ’ (t + op-time op) (projâ‚ (unpack-Ã—áµ— qy))) (projâ‚‚ (unpack-Ã—áµ— qy)))}
                  (trans
                    (congâ‚‚ k
                      (â‰¤-irrelevant _ _)
                      (sym (cong projâ‚‚ (unpack-Ã—áµ—-monotone {homáµ’ (t + op-time op)} {âŸ¦ arity op âŸ§áµ} p qy))))
                    (k-nat p (unpack-homáµ’ (t + op-time op) (projâ‚ (unpack-Ã—áµ— qy))) (projâ‚‚ (unpack-Ã—áµ— qy)))))
                (handleË¢-â‰¤t-nat p h f (k (unpack-homáµ’ (t + op-time op) (projâ‚ (unpack-Ã—áµ— qy))) (projâ‚‚ (unpack-Ã—áµ— qy)))))))))
  handleË¢ h f (delay Ï„ k) =
    Ï„-subst
      (sym (+-assoc Ï„ _ _))
      (delay Ï„ (handleË¢ h f k))

  handleË¢-â‰¤t-nat : âˆ€ {A B Ï„ Ï„'} â†’ {t t' : â„•} â†’ (p : t â‰¤ t')
                 â†’ (h : (op : Op) â†’ (Ï„'' : Time) â†’
                          âŸ¦ param op âŸ§áµ Ã—áµ— ([ op-time op ]áµ’ (âŸ¦ arity op âŸ§áµ â‡’áµ— Táµ’ B Ï„'')) â†’áµ— Táµ’ B (op-time op + Ï„''))
                 â†’ (f : A â†’áµ— Táµ’ B Ï„')
                 â†’ (c : TË¢ A Ï„ t)
                 â†’ handleË¢ h f (TË¢-â‰¤t p c)
                 â‰¡ TË¢-â‰¤t p (handleË¢ h f c)
  handleË¢-â‰¤t-nat p h f (leaf v) =
    map-nat f p v
  handleË¢-â‰¤t-nat {A} {B} {Ï„' = Ï„'} p h f (node {Ï„ = Ï„} op v k k-nat) =
    trans
      (cong (Ï„-subst (sym (+-assoc (op-time op) Ï„ Ï„')))
        (trans
          (cong (map-carrier (h op (Ï„ + Ï„')))
            (trans
              (cong pack-Ã—áµ—
                (cong (monotone âŸ¦ param op âŸ§áµ p v ,_)
                  (trans
                    (cong pack-â‡’áµ—
                      (dcongâ‚‚ tset-map
                        (ifun-ext (fun-ext (Î» qy â†’
                          congâ‚‚ (Î» q y â†’ handleË¢ h f (k q y))
                            (â‰¤-irrelevant _ _)
                            (sym (cong projâ‚‚ (pack-unpack-Ã—áµ— _))))))
                        (ifun-ext (ifun-ext (fun-ext (Î» q â†’ fun-ext (Î» ry â†’ uip)))))))
                    (sym (pack-â‡’áµ—-monotone _ _)))))
              (sym
                (pack-Ã—áµ—-monotone
                  {âŸ¦ param op âŸ§áµ}
                  {[ op-time op ]áµ’ (âŸ¦ arity op âŸ§áµ â‡’áµ— Táµ’ B (Ï„ + Ï„'))}
                  p _))))
          (map-nat (h op (Ï„ + Ï„')) p _)))
      (sym (Ï„-subst-â‰¤t (sym (+-assoc (op-time op) Ï„ Ï„')) p _))
  handleË¢-â‰¤t-nat p h f (delay Ï„ k) =
    trans
      (cong (Ï„-subst (sym (+-assoc Ï„ _ _)))
        (cong (delay Ï„)
          (handleË¢-â‰¤t-nat (+-monoË¡-â‰¤ Ï„ p) h f k)))
      (sym (Ï„-subst-â‰¤t (sym (+-assoc Ï„ _ _)) p
             (delay Ï„ (handleË¢ h f k))))

abstract
  handleáµ€ : âˆ€ {A B Ï„ Ï„'}
          â†’ ((op : Op) â†’ (Ï„'' : Time) â†’
               âŸ¦ param op âŸ§áµ Ã—áµ— ([ op-time op ]áµ’ (âŸ¦ arity op âŸ§áµ â‡’áµ— Táµ’ B Ï„'')) â†’áµ— Táµ’ B (op-time op + Ï„''))
          â†’ A â†’áµ— Táµ’ B Ï„'
          â†’ Táµ’ A Ï„ â†’áµ— Táµ’ B (Ï„ + Ï„')
  handleáµ€ h f =
    tset-map (handleË¢ h f) (Î» p â†’ handleË¢-â‰¤t-nat p h f)































---------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------


{-


-- Candidate for object-mapping of the underlying functor to support quotienting by delay equations
-- NOTE: quick sketch, does not include naturality condition for operation nodes


mutual
  
  data TË¢ (A : TSet) : (Ï„ : Time) â†’ (t : Time) â†’ Set where  -- 1st time index (Ï„) is the duration of the computation (its time-grading)
                                                            -- 2nd time index (t) is the corresponding TSets' time-index (presheaf index)
    delay : âˆ€ {Ï„' t}
          â†’ (Ï„ : Time)
          â†’ 0 < Ï„
          â†’ Tá¶œË¢ A Ï„' (t + Ï„)
          â†’ TË¢ A (Ï„ + Ï„') t
    comp  : âˆ€ {Ï„ t}
          â†’ Tá¶œË¢ A Ï„ t
          â†’ TË¢ A Ï„ t
  data Tá¶œË¢ (A : TSet) : (Ï„ : Time) â†’ (t : Time) â†’ Set where  -- 1st time index (Ï„) is the duration of the computation (its time-grading)
                                                             -- 2nd time index (t) is the corresponding TSets' time-index (presheaf index)
    leaf  : âˆ€ {t}
          â†’ carrier A t
          â†’ Tá¶œË¢ A 0 t
     
    node  : âˆ€ {Ï„ t}
          â†’ (op : Op)
          â†’ carrier âŸ¦ param op âŸ§áµ t
          â†’ ({t' : Time} â†’ t + op-time op â‰¤ t'
                         â†’ carrier âŸ¦ arity op âŸ§áµ t'
                         â†’ TË¢ A Ï„ t')
          â†’ Tá¶œË¢ A (op-time op + Ï„) t

-}
