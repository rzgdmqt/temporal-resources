---------------------------------------------------------
-- Free graded monad generated by algebraic operations --
---------------------------------------------------------

-- Note: A version of the monad that is not quotioned by
--       the delay equations (identity and composition)

open import Function

open import Data.Empty
open import Data.Product
open import Data.Unit hiding (_â‰¤_)

open import Semantics.TSets
open import Semantics.Modality.Future
open import Semantics.Modality.Past

open import Util.Equality
open import Util.Operations
open import Util.Time

module Semantics.Monad.Core where

-- Interpretation of ground types
---------------------------------

âŸ¦_âŸ§áµ : GType â†’ TSet
âŸ¦ Base B âŸ§áµ   = ConstTSet (BaseSet B)
âŸ¦ Unit âŸ§áµ     = ğŸ™áµ—
âŸ¦ Empty âŸ§áµ    = ğŸ˜áµ—
âŸ¦ [ Ï„ ]áµ A âŸ§áµ = [ Ï„ ]áµ’ âŸ¦ A âŸ§áµ


-- The free graded monad generated by the operations in Op
----------------------------------------------------------

-- Object mapping and time-monotonicity

mutual

  data TË¢ (A : TSet) : (Ï„ : Time) â†’ (t : Time) â†’ Set where

    leaf  : âˆ€ {t}
          â†’ carrier A t
          â†’ TË¢ A 0 t
       
    node  : âˆ€ {Ï„ t}
          â†’ (op : Op)
          â†’ carrier âŸ¦ param op âŸ§áµ t
          â†’ (k : {t' : Time} â†’ t + op-time op â‰¤ t'
                             â†’ carrier âŸ¦ arity op âŸ§áµ t'
                             â†’ TË¢ A Ï„ t')
          â†’ ({t' t'' : Time} â†’ (p : t' â‰¤ t'')                                       -- time-naturality of continuation
                             â†’ (q : t + op-time op â‰¤ t')
                             â†’ (y : carrier âŸ¦ arity op âŸ§áµ t')
                             â†’ k (â‰¤-trans q p) (monotone (âŸ¦ arity op âŸ§áµ) p y)
                             â‰¡ TË¢-â‰¤t p (k q y))
          â†’ TË¢ A (op-time op + Ï„) t
     
    delay : âˆ€ {Ï„' t}
          â†’ (Ï„ : Time)
          â†’ TË¢ A Ï„' (t + Ï„)
          â†’ TË¢ A (Ï„ + Ï„') t


  TË¢-â‰¤t : âˆ€ {A Ï„ t t'} â†’ t â‰¤ t' â†’ TË¢ A Ï„ t â†’ TË¢ A Ï„ t'
  TË¢-â‰¤t {A} p (leaf v) =
    leaf (monotone A p v)
  TË¢-â‰¤t p (node op v k k-nat) =
    node op
      (monotone (âŸ¦ param op âŸ§áµ) p v)
      (Î» q y â†’ k (â‰¤-trans (+-monoË¡-â‰¤ (op-time op) p) q) y)
      (Î» p q y â†’
        trans
          (cong (Î» q â†’ k q (monotone âŸ¦ arity op âŸ§áµ p y)) (â‰¤-irrelevant _ _))
          (k-nat _ _ y))
  TË¢-â‰¤t p (delay Ï„ k) =
    delay Ï„ (TË¢-â‰¤t (+-monoË¡-â‰¤ Ï„ p) k)


-- Reflexivity and transitivity of time-monotonicity

TË¢-â‰¤t-refl : âˆ€ {A Ï„ t} â†’ (c : TË¢ A Ï„ t) â†’ TË¢-â‰¤t â‰¤-refl c â‰¡ c
TË¢-â‰¤t-refl {A} (leaf v) =
  cong leaf (monotone-refl A v)
TË¢-â‰¤t-refl {A = A} {t = t} (node {Ï„ = Ï„} op v k k-nat) =
  dcongâ‚ƒ (node op)
    (monotone-refl âŸ¦ param op âŸ§áµ v)
    (ifun-ext (fun-ext (Î» p â†’ fun-ext (Î» y â†’
      trans
        (cong (Î» (k : {t' : Time} â†’ t + op-time op â‰¤ t' â†’ carrier âŸ¦ arity op âŸ§áµ t' â†’ TË¢ A Ï„ t') â†’ k p y)
          {subst (Î» _ â†’ {t' : Time} â†’ t + op-time op â‰¤ t' â†’ carrier âŸ¦ arity op âŸ§áµ t' â†’ TË¢ A Ï„ t')
              (monotone-refl âŸ¦ param op âŸ§áµ v)
              (Î» q â†’ k (â‰¤-trans (+-monoË¡-â‰¤ (op-time op) â‰¤-refl) q))}
          (subst-const _ (monotone-refl âŸ¦ param op âŸ§áµ v) _))
        (cong (Î» p â†’ k p y) (â‰¤-irrelevant _ _))))))
    (ifun-ext (ifun-ext (fun-ext (Î» p â†’ fun-ext (Î» q â†’ fun-ext (Î» y â†’ uip))))))
TË¢-â‰¤t-refl (delay Ï„ k) =
  cong (delay Ï„)
    (trans
      (cong (Î» p â†’ TË¢-â‰¤t p k) (â‰¤-irrelevant _ _))
      (TË¢-â‰¤t-refl k))

TË¢-â‰¤t-trans : âˆ€ {A Ï„ t t' t''}
            â†’ (p : t â‰¤ t') â†’ (q : t' â‰¤ t'') â†’ (c : TË¢ A Ï„ t)
            â†’ TË¢-â‰¤t q (TË¢-â‰¤t p c) â‰¡ TË¢-â‰¤t (â‰¤-trans p q) c
TË¢-â‰¤t-trans {A} p q (leaf v) =
  cong leaf (monotone-trans A p q v)
TË¢-â‰¤t-trans {A = A} {t'' = t''} p q (node {Ï„ = Ï„} op v k k-nat) =
  dcongâ‚ƒ (node op)
    (monotone-trans (âŸ¦ param op âŸ§áµ) p q v)
    (ifun-ext (fun-ext (Î» r â†’ fun-ext (Î» y â†’
      trans
        (cong (Î» (k : {t''' : Time} â†’ t'' + op-time op â‰¤ t''' â†’ carrier âŸ¦ arity op âŸ§áµ t''' â†’ TË¢ A Ï„ t''') â†’ k r y)
          {subst
            (Î» _ â†’ {t' = t''' : Time} â†’ t'' + op-time op â‰¤ t''' â†’ carrier âŸ¦ arity op âŸ§áµ t''' â†’ TË¢ A Ï„ t''')
            (monotone-trans âŸ¦ param op âŸ§áµ p q v)
            (Î» r â†’ k (â‰¤-trans (+-monoË¡-â‰¤ (op-time op) p) (â‰¤-trans (+-monoË¡-â‰¤ (op-time op) q) r)))}
          (subst-const _ (monotone-trans âŸ¦ param op âŸ§áµ p q v) _))
        (cong (Î» p â†’ k p y) (â‰¤-irrelevant _ _))))))
    (ifun-ext (ifun-ext (fun-ext (Î» p â†’ fun-ext (Î» q â†’ fun-ext (Î» y â†’ uip))))))
TË¢-â‰¤t-trans p q (delay Ï„ k) =
  cong (delay Ï„)
    (trans
      (TË¢-â‰¤t-trans (+-monoË¡-â‰¤ Ï„ p) (+-monoË¡-â‰¤ Ï„ q) k)
      (cong (Î» p â†’ TË¢-â‰¤t p k) (â‰¤-irrelevant _ _)))


-- "subst" for time-gradings

Ï„-subst : âˆ€ {A Ï„ Ï„' t}
        â†’ Ï„ â‰¡ Ï„'
        â†’ TË¢ A Ï„ t
        â†’ TË¢ A Ï„' t
Ï„-subst refl c = c

Ï„-subst-â‰¤t : âˆ€ {A Ï„ Ï„' t t'}
           â†’ (p : Ï„ â‰¡ Ï„')
           â†’ (q : t â‰¤ t')
           â†’ (c : TË¢ A Ï„ t)
           â†’ TË¢-â‰¤t q (Ï„-subst p c) â‰¡ Ï„-subst p (TË¢-â‰¤t q c)
Ï„-subst-â‰¤t refl q c = refl


-- Functorial action (TODO: prove identity and composition laws)

mutual

  -- TODO: investigate how to convince Agda's termination checker;
  --       the "suspicious" recursive occurrences of `TË¢á¶ ` are in 
  --       types (but still applied to the continuation `k`);
  --       so maybe it is enough to index the trees by their height
  --
  --       same also applies for definitions below

  {-# TERMINATING #-}

  TË¢á¶  : âˆ€ {A B Ï„} â†’ A â†’áµ— B â†’ {t : Time} â†’ TË¢ A Ï„ t â†’ TË¢ B Ï„ t
  TË¢á¶  f (leaf v) =
    leaf (map-carrier f v)
  TË¢á¶  f (node op v k k-nat) =
    node op v
      (Î» p y â†’ TË¢á¶  f (k p y))
      (Î» p q y â†’
        trans
          (cong (TË¢á¶  f) (k-nat p q y))
          (TË¢á¶ -â‰¤t-nat f p (k q y)))    
  TË¢á¶  f (delay Ï„ k) =
    delay Ï„ (TË¢á¶  f k)

  TË¢á¶ -â‰¤t-nat : âˆ€ {A B Ï„} â†’ (f : A â†’áµ— B) â†’ {t t' : â„•}
             â†’ (p : t â‰¤ t') â†’ (c : TË¢ A Ï„ t)
             â†’ TË¢á¶  f (TË¢-â‰¤t p c) â‰¡ TË¢-â‰¤t p (TË¢á¶  f c)
  TË¢á¶ -â‰¤t-nat f p (leaf v) =
    cong leaf (map-nat f p v)
  TË¢á¶ -â‰¤t-nat f p (node op v k k-nat) =
    dcongâ‚ƒ (node op)
      refl
      refl
      (ifun-ext (ifun-ext (fun-ext (Î» p â†’ fun-ext (Î» q â†’ fun-ext (Î» y â†’ uip))))))
  TË¢á¶ -â‰¤t-nat f p (delay Ï„ k) =
    cong (delay Ï„) (TË¢á¶ -â‰¤t-nat f (+-monoË¡-â‰¤ Ï„ p) k)


-- Packaging it all up into a functor on TSet

Táµ’ : TSet â†’ Time â†’ TSet
Táµ’ A Ï„ = tset (TË¢ A Ï„) TË¢-â‰¤t TË¢-â‰¤t-refl TË¢-â‰¤t-trans
 
Tá¶  : âˆ€ {A B Ï„} â†’ A â†’áµ— B â†’ Táµ’ A Ï„ â†’áµ— Táµ’ B Ï„
Tá¶  f = tset-map (TË¢á¶  f) (TË¢á¶ -â‰¤t-nat f)


-- Unit (TODO: prove naturality and laws)

Î·áµ€ : âˆ€ {A} â†’ A â†’áµ— Táµ’ A 0
Î·áµ€ =
  tset-map
    (Î» v â†’ leaf v)
    (Î» p v â†’ refl)


-- Multiplication (TODO: prove naturality and laws)

mutual

  {-# TERMINATING #-}

  Î¼Ë¢ : âˆ€ {A Ï„ Ï„'} â†’ {t : Time}
     â†’ TË¢ (Táµ’ A Ï„') Ï„ t â†’ TË¢ A (Ï„ + Ï„') t
  Î¼Ë¢ (leaf c) =
    c
  Î¼Ë¢ (node op v k k-nat) =
    Ï„-subst
      (sym (+-assoc (op-time op) _ _))
      (node op v
        (Î» p y â†’ Î¼Ë¢ (k p y))
        (Î» p q y â†’
          trans
            (cong Î¼Ë¢ (k-nat p q y))
            (Î¼Ë¢-â‰¤t-nat p (k q y))))
  Î¼Ë¢ (delay Ï„ k) =
    Ï„-subst (sym (+-assoc Ï„ _ _)) (delay Ï„ (Î¼Ë¢ k))

  Î¼Ë¢-â‰¤t-nat : âˆ€ {A Ï„ Ï„'} â†’ {t t' : â„•}
          â†’ (p : t â‰¤ t')
          â†’ (c : TË¢ (Táµ’ A Ï„') Ï„ t)
          â†’ Î¼Ë¢ (TË¢-â‰¤t p c) â‰¡ TË¢-â‰¤t p (Î¼Ë¢ c)
  Î¼Ë¢-â‰¤t-nat p (leaf v) =
    refl
  Î¼Ë¢-â‰¤t-nat p (node op v k k-nat) =
    trans
      (cong (Ï„-subst (sym (+-assoc (op-time op) _ _)))
        (dcongâ‚‚ (node op (monotone âŸ¦ param op âŸ§áµ p v))
          refl
          (ifun-ext (ifun-ext (fun-ext (Î» q â†’ fun-ext (Î» r â†’ fun-ext (Î» y â†’ uip))))))))
      (sym (Ï„-subst-â‰¤t (sym (+-assoc (op-time op) _ _)) p _))
  Î¼Ë¢-â‰¤t-nat p (delay Ï„ k) =
    trans
      (cong
        (Ï„-subst (sym (+-assoc Ï„ _ _)))
        (cong (delay Ï„) (Î¼Ë¢-â‰¤t-nat (+-monoË¡-â‰¤ Ï„ p) k)))
      (sym (Ï„-subst-â‰¤t (sym (+-assoc Ï„ _ _)) p (delay Ï„ (Î¼Ë¢ k))))

Î¼áµ€ : âˆ€ {A Ï„ Ï„'}
   â†’ Táµ’ (Táµ’ A Ï„') Ï„ â†’áµ— Táµ’ A (Ï„ + Ï„')
Î¼áµ€ = tset-map Î¼Ë¢ Î¼Ë¢-â‰¤t-nat

































---------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------


{-


-- Candidate for object-mapping of the underlying functor to support quotienting by delay equations
-- NOTE: quick sketch, does not include naturality condition for operation nodes


mutual
  
  data TË¢ (A : TSet) : (Ï„ : Time) â†’ (t : Time) â†’ Set where  -- 1st time index (Ï„) is the duration of the computation (its time-grading)
                                                            -- 2nd time index (t) is the corresponding TSets' time-index (presheaf index)
    delay : âˆ€ {Ï„' t}
          â†’ (Ï„ : Time)
          â†’ 0 < Ï„
          â†’ Tá¶œË¢ A Ï„' (t + Ï„)
          â†’ TË¢ A (Ï„ + Ï„') t
    comp  : âˆ€ {Ï„ t}
          â†’ Tá¶œË¢ A Ï„ t
          â†’ TË¢ A Ï„ t
  data Tá¶œË¢ (A : TSet) : (Ï„ : Time) â†’ (t : Time) â†’ Set where  -- 1st time index (Ï„) is the duration of the computation (its time-grading)
                                                             -- 2nd time index (t) is the corresponding TSets' time-index (presheaf index)
    leaf  : âˆ€ {t}
          â†’ carrier A t
          â†’ Tá¶œË¢ A 0 t
     
    node  : âˆ€ {Ï„ t}
          â†’ (op : Op)
          â†’ carrier âŸ¦ param op âŸ§áµ t
          â†’ ({t' : Time} â†’ t + op-time op â‰¤ t'
                         â†’ carrier âŸ¦ arity op âŸ§áµ t'
                         â†’ TË¢ A Ï„ t')
          â†’ Tá¶œË¢ A (op-time op + Ï„) t

-}
