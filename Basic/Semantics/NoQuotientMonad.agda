---------------------------------------------------------
-- Free graded monad generated by algebraic operations --
---------------------------------------------------------

-- Note: A version of the monad that is not quotioned by
--       the delay equations (identity and composition)

open import Function

open import Data.Empty
open import Data.Product
open import Data.Unit hiding (_â‰¤_)

open import Semantics.TSets
open import Semantics.Modality.Future
open import Semantics.Modality.Past

open import Util.HProp
open import Util.Equality
open import Util.Operations
open import Util.Time

module Semantics.NoQuotientMonad where

-- Interpretation of ground types
---------------------------------

âŸ¦_âŸ§áµ : GType â†’ TSet
âŸ¦ Base B âŸ§áµ   = ConstTSet (BaseSet B)
âŸ¦ Unit âŸ§áµ     = ğŸ™áµ—
âŸ¦ Empty âŸ§áµ    = ğŸ˜áµ—
âŸ¦ [ Ï„ ]áµ A âŸ§áµ = [ Ï„ ]áµ’ âŸ¦ A âŸ§áµ

-- The free graded monad generated by the operations in Op
----------------------------------------------------------

-- Skeletal object mapping

data TË¢ (A : TSet) : (Ï„ : Time) â†’ (t : Time) â†’ Set where  -- 1st time index (Ï„) is the duration of the computation (its time-grading)
                                                          -- 2nd time index (t) is the corresponding TSets' time-index (presheaf index)
  leaf  : âˆ€ {t}
        â†’ carrier A t
        â†’ TË¢ A 0 t
     
  node  : âˆ€ {Ï„ t}
        â†’ (op : Op)
        â†’ carrier âŸ¦ param op âŸ§áµ t
        â†’ ({t' : Time} â†’ t + op-time op â‰¤ t'
                       â†’ carrier âŸ¦ arity op âŸ§áµ t'
                       â†’ TË¢ A Ï„ t')
        â†’ TË¢ A (op-time op + Ï„) t

  delay : âˆ€ {Ï„' t}
        â†’ (Ï„ : Time)
        â†’ TË¢ A Ï„' (t + Ï„)
        â†’ TË¢ A (Ï„ + Ï„') t


-- Monotonicity with respect to the (presheaf) time indices

TË¢-â‰¤t : âˆ€ {A Ï„ t t'} â†’ t â‰¤ t' â†’ TË¢ A Ï„ t â†’ TË¢ A Ï„ t'
TË¢-â‰¤t {A} p (leaf v) =
  leaf (monotone A p v)
TË¢-â‰¤t p (node op v k) =
  node op
    (monotone (âŸ¦ param op âŸ§áµ) p v)
    (Î» q y â†’ k (â‰¤-trans (+-monoË¡-â‰¤ (op-time op) p) q) y)
TË¢-â‰¤t p (delay Ï„ k) =
  delay Ï„ (TË¢-â‰¤t (+-monoË¡-â‰¤ Ï„ p) k)

TË¢-â‰¤t-refl : âˆ€ {A Ï„ t} â†’ (c : TË¢ A Ï„ t) â†’ TË¢-â‰¤t â‰¤-refl c â‰¡ c
TË¢-â‰¤t-refl {A} (leaf v) =
  cong leaf (monotone-refl A v)
TË¢-â‰¤t-refl (node op v k) =
  congâ‚‚ (node op)
    (monotone-refl âŸ¦ param op âŸ§áµ v)
    (ifun-ext (fun-ext (Î» p â†’ fun-ext (Î» y â†’ cong (Î» p â†’ k p y) (â‰¤-irrelevant _ _)))))
TË¢-â‰¤t-refl (delay Ï„ k) =
  cong (delay Ï„)
    (trans
      (cong (Î» p â†’ TË¢-â‰¤t p k) (â‰¤-irrelevant _ _))
      (TË¢-â‰¤t-refl k))

TË¢-â‰¤t-trans : âˆ€ {A Ï„ t t' t''}
            â†’ (p : t â‰¤ t') â†’ (q : t' â‰¤ t'') â†’ (c : TË¢ A Ï„ t)
            â†’ TË¢-â‰¤t q (TË¢-â‰¤t p c) â‰¡ TË¢-â‰¤t (â‰¤-trans p q) c
TË¢-â‰¤t-trans {A} p q (leaf v) =
  cong leaf (monotone-trans A p q v)
TË¢-â‰¤t-trans p q (node op v k) =
  congâ‚‚ (node op)
    (monotone-trans (âŸ¦ param op âŸ§áµ) p q v)
    (ifun-ext (fun-ext (Î» r â†’ fun-ext (Î» y â†’ cong (Î» p â†’ k p y) (â‰¤-irrelevant _ _)))))
TË¢-â‰¤t-trans p q (delay Ï„ k) =
  cong (delay Ï„)
    (trans
      (TË¢-â‰¤t-trans (+-monoË¡-â‰¤ Ï„ p) (+-monoË¡-â‰¤ Ï„ q) k)
      (cong (Î» p â†’ TË¢-â‰¤t p k) (â‰¤-irrelevant _ _)))


-- "subst" for time-gradings

Ï„-subst : âˆ€ {A Ï„ Ï„' t}
        â†’ Ï„ â‰¡ Ï„'
        â†’ TË¢ A Ï„ t
        â†’ TË¢ A Ï„' t
Ï„-subst refl c = c

Ï„-subst-â‰¤t : âˆ€ {A Ï„ Ï„' t t'}
           â†’ (p : Ï„ â‰¡ Ï„')
           â†’ (q : t â‰¤ t')
           â†’ (c : TË¢ A Ï„ t)
           â†’ TË¢-â‰¤t q (Ï„-subst p c) â‰¡ Ï„-subst p (TË¢-â‰¤t q c)
Ï„-subst-â‰¤t refl q c = refl

Ï„-subst-delay : âˆ€ {A Ï„ Ï„' Ï„'' t}
              â†’ (p : Ï„' â‰¡ Ï„'')
              â†’ (c : TË¢ A Ï„' (t + Ï„))
              â†’ Ï„-subst (cong (Ï„ +_) p) (delay Ï„ c) â‰¡ delay Ï„ (Ï„-subst p c)
Ï„-subst-delay refl c = refl


-- Functorial action (TODO: prove identity and composition laws)

TË¢á¶  : âˆ€ {A B Ï„} â†’ A â†’áµ— B â†’ {t : Time} â†’ TË¢ A Ï„ t â†’ TË¢ B Ï„ t
TË¢á¶  f (leaf v) =
  leaf (map-carrier f v)
TË¢á¶  f (node op v k) =
  node op v Î» p y â†’ TË¢á¶  f (k p y)
TË¢á¶  f (delay Ï„ k) =
  delay Ï„ (TË¢á¶  f k)

TË¢á¶ -â‰¤t-nat : âˆ€ {A B Ï„} â†’ (f : A â†’áµ— B) â†’ {t t' : â„•}
           â†’ (p : t â‰¤ t') â†’ (c : TË¢ A Ï„ t)
           â†’ TË¢á¶  f (TË¢-â‰¤t p c) â‰¡ TË¢-â‰¤t p (TË¢á¶  f c)
TË¢á¶ -â‰¤t-nat f p (leaf v) =
  cong leaf (map-nat f p v)
TË¢á¶ -â‰¤t-nat f p (node op v k) =
  congâ‚‚ (node op) refl refl
TË¢á¶ -â‰¤t-nat f p (delay Ï„ k) =
  cong (delay Ï„) (TË¢á¶ -â‰¤t-nat f (+-monoË¡-â‰¤ Ï„ p) k)


-- Packaging it all up into a functor on TSet

Táµ’ : TSet â†’ Time â†’ TSet
Táµ’ A Ï„ = tset (TË¢ A Ï„) TË¢-â‰¤t TË¢-â‰¤t-refl TË¢-â‰¤t-trans

Tá¶  : âˆ€ {A B Ï„} â†’ A â†’áµ— B â†’ Táµ’ A Ï„ â†’áµ— Táµ’ B Ï„
Tá¶  f = tset-map (TË¢á¶  f) (TË¢á¶ -â‰¤t-nat f)


-- Unit (TODO: prove naturality and laws)

Î·áµ€ : âˆ€ {A} â†’ A â†’áµ— Táµ’ A 0
Î·áµ€ =
  tset-map
    (Î» v â†’ leaf v)
    (Î» p v â†’ refl)


-- Multiplication (TODO: prove naturality and laws)

Î¼Ë¢ : âˆ€ {A Ï„ Ï„'} â†’ {t : Time}
   â†’ TË¢ (Táµ’ A Ï„') Ï„ t â†’ TË¢ A (Ï„ + Ï„') t
Î¼Ë¢ (leaf c) =
  c
Î¼Ë¢ {A = A} {t = t} (node op v k) =
  Ï„-subst
    (sym (+-assoc (op-time op) _ _))
    (node op v (Î» p y â†’ Î¼Ë¢ (k p y)))
Î¼Ë¢ {A = A} {t = t} (delay Ï„ k) =
  Ï„-subst (sym (+-assoc Ï„ _ _)) (delay Ï„ (Î¼Ë¢ k))

Î¼Ë¢-â‰¤t-nat : âˆ€ {A Ï„ Ï„'} â†’ {t t' : â„•}
          â†’ (p : t â‰¤ t')
          â†’ (c : TË¢ (Táµ’ A Ï„') Ï„ t)
          â†’ Î¼Ë¢ (TË¢-â‰¤t p c) â‰¡ TË¢-â‰¤t p (Î¼Ë¢ c)
Î¼Ë¢-â‰¤t-nat p (leaf v) =
  refl
Î¼Ë¢-â‰¤t-nat p (node op v k) =
  (sym (Ï„-subst-â‰¤t
    (sym (+-assoc (op-time op) _ _)) p
    (node op v (Î» q y â†’ Î¼Ë¢ (k q y)))))
Î¼Ë¢-â‰¤t-nat p (delay Ï„ k) =
  trans
    (cong
      (Ï„-subst (sym (+-assoc Ï„ _ _)))
      (cong (delay Ï„) (Î¼Ë¢-â‰¤t-nat (+-monoË¡-â‰¤ Ï„ p) k)))
    (sym (Ï„-subst-â‰¤t (sym (+-assoc Ï„ _ _)) p (delay Ï„ (Î¼Ë¢ k))))

Î¼áµ€ : âˆ€ {A Ï„ Ï„'}
   â†’ Táµ’ (Táµ’ A Ï„') Ï„ â†’áµ— Táµ’ A (Ï„ + Ï„')
Î¼áµ€ = tset-map Î¼Ë¢ Î¼Ë¢-â‰¤t-nat


-- Strength (TODO: prove naturality and laws)

strË¢ : âˆ€ {A B Ï„ Ï„' t}
     â†’ carrier ([ Ï„ ]áµ’ (âŸ¨ Ï„' âŸ©áµ’ A)) t
     â†’ TË¢ B Ï„ t
     â†’ TË¢ (âŸ¨ Ï„' âŸ©áµ’ A Ã—áµ— B) Ï„ t
strË¢ {A} {Ï„' = Ï„'} v (leaf w) =
  leaf ((â‰¤-trans (projâ‚ v) (â‰¤-reflexive (+-identityÊ³ _)) ,
         monotone A
           (â‰¤-reflexive (cong (_âˆ¸ Ï„') (+-identityÊ³ _)))
           (projâ‚‚ v)) ,
        w)
strË¢ {A} {B} {_} {Ï„'} {t} v (node op w k) =
  node op w (Î» p y â†’
    strË¢
      {A} {B}
      (monotone (âŸ¨ Ï„' âŸ©áµ’ A)
        (â‰¤-trans
          (â‰¤-reflexive (sym (+-assoc t _ _)))
          (+-monoË¡-â‰¤ _ p))
        v)
      (k p y))
strË¢ {A} {B} {_} {Ï„'} {t} v (delay Ï„ k) =
  delay Ï„
    (strË¢ {A} {B}
      (monotone (âŸ¨ Ï„' âŸ©áµ’ A) (â‰¤-reflexive (sym (+-assoc t _ _))) v)
      k)

strË¢-â‰¤t-nat : âˆ€ {A B Ï„ Ï„'} â†’ {t t' : â„•} â†’ (p : t â‰¤ t')
            â†’ (v : carrier ([ Ï„ ]áµ’ (âŸ¨ Ï„' âŸ©áµ’ A)) t)
            â†’ (c : TË¢ B Ï„ t)
            â†’ strË¢ {A = A} {B = B}
                (monotone ([ Ï„ ]áµ’ (âŸ¨ Ï„' âŸ©áµ’ A)) p v)
                (TË¢-â‰¤t p c)
            â‰¡ TË¢-â‰¤t p (strË¢ {A = A} {B = B} v c)
strË¢-â‰¤t-nat {A} {B} {_} {Ï„'} {t} {t'} p v (leaf w) =
  cong leaf
    (cong (_, monotone B p w)
      (congâ‚‚ _,_
        (â‰¤-irrelevant _ _)
        (trans
          (trans
            (monotone-trans A _ _ (projâ‚‚ v))
            (cong (Î» p â†’ monotone A p (projâ‚‚ v)) (â‰¤-irrelevant _ _)))
          (sym (monotone-trans A _ _ (projâ‚‚ v))))))
strË¢-â‰¤t-nat {A} {B} p v (node op w k) =
  cong (node op (monotone âŸ¦ param op âŸ§áµ p w))
    (ifun-ext (fun-ext (Î» q â†’ fun-ext (Î» y â†’
      cong (Î» v â†’ strË¢ {A} {B} v (k (â‰¤-trans (+-monoË¡-â‰¤ (op-time op) p) q) y))
        (congâ‚‚ _,_
          (â‰¤-irrelevant _ _)
          (trans
            (monotone-trans A _ _ (projâ‚‚ v))
            (cong (Î» p â†’ monotone A p (projâ‚‚ v)) (â‰¤-irrelevant _ _)))))))) 
strË¢-â‰¤t-nat {A} {B} {_} {Ï„'} {t} {t'} p v (delay Ï„ k) =
  cong (delay Ï„)
    (trans
      (cong (Î» v â†’ strË¢ {A} {B} v (TË¢-â‰¤t (+-monoË¡-â‰¤ _ p) k))
        (congâ‚‚ _,_
          (â‰¤-irrelevant _ _)
          (trans
            (monotone-trans A _ _ (projâ‚‚ v))
            (trans
              (cong (Î» p â†’ monotone A p (projâ‚‚ v)) (â‰¤-irrelevant _ _))
              (sym (monotone-trans A _ _ (projâ‚‚ v)))))))
      (strË¢-â‰¤t-nat
        (+-monoË¡-â‰¤ Ï„ p)
        (monotone (âŸ¨ Ï„' âŸ©áµ’ A) (â‰¤-reflexive (sym (+-assoc t _ _))) v)
        k))

stráµ€ : âˆ€ {A B Ï„ Ï„'}
     â†’ [ Ï„ ]áµ’ (âŸ¨ Ï„' âŸ©áµ’ A) Ã—áµ— Táµ’ B Ï„ â†’áµ— Táµ’ (âŸ¨ Ï„' âŸ©áµ’ A Ã—áµ— B) Ï„
stráµ€ {A} {B} =
  tset-map
    (Î» { (v , c) â†’ strË¢ {A} {B} v c })
    (Î» { p (v , c) â†’ strË¢-â‰¤t-nat p v c })


-- Effect handling / free algebras

handleË¢ : âˆ€ {A B Ï„ Ï„' t}
        â†’ ((op : Op) â†’ (Ï„'' : Time) â†’
             âŸ¦ param op âŸ§áµ Ã—áµ— ([ op-time op ]áµ’ (âŸ¦ arity op âŸ§áµ â‡’áµ— Táµ’ B Ï„'')) â†’áµ— Táµ’ B (op-time op + Ï„''))
        â†’ A â†’áµ— Táµ’ B Ï„'
        â†’ TË¢ A Ï„ t
        â†’ TË¢ B (Ï„ + Ï„') t
handleË¢ h f (leaf v) =
  map-carrier f v
handleË¢ {A} {B} {t = t} h f (node op v k) =
  Ï„-subst
    (sym (+-assoc (op-time op) _ _))
    (map-carrier (h op _)
      (v ,
       subst id (sym (reveal-â‡’áµ— (âŸ¦ arity op âŸ§áµ) (Táµ’ B _) _))
         (tset-map
           (Î» { (q , y) â†’ handleË¢ h f (k (subst id (reveal-homáµ’ (t + op-time op) _) q) y) })
           (Î» { p (q , y) â†’ {!!} }))))                                                              -- if the handler is assumed to be monotone, then we need to
handleË¢ h f (delay Ï„ k) =                                                                           -- prove here (simultaneously) that handleË¢ is monotone as well
  Ï„-subst
    (sym (+-assoc Ï„ _ _))
    (delay Ï„ (handleË¢ h f k))


{-
handleË¢ : âˆ€ {A B Ï„ Ï„' t}
        â†’ ((op : Op) â†’ (Ï„'' : Time) â†’ {t' : Time} â†’
             carrier âŸ¦ param op âŸ§áµ t' â†’
             ({t'' : Time} â†’ t' + op-time op â‰¤ t'' â†’ carrier âŸ¦ arity op âŸ§áµ t'' â†’ TË¢ B Ï„'' t'') â†’
             TË¢ B (op-time op + Ï„'') t')
        â†’ A â†’áµ— Táµ’ B Ï„'
        â†’ TË¢ A Ï„ t
        â†’ TË¢ B (Ï„ + Ï„') t
handleË¢ h f (leaf v) =
  map-carrier f v
handleË¢ h f (node op v k) =
  Ï„-subst
    (sym (+-assoc (op-time op) _ _))
    (h op _ v (Î» p y â†’ handleË¢ h f (k p y)))
handleË¢ h f (delay Ï„ k) =
  Ï„-subst
    (sym (+-assoc Ï„ _ _))
    (delay Ï„ (handleË¢ h f k))

handleË¢-â‰¤t-nat : âˆ€ {A B Ï„ Ï„'} â†’ {t t' : â„•} â†’ (p : t â‰¤ t')
               â†’ (h : (op : Op) â†’ (Ï„'' : Time) â†’ {t' : Time} â†’
                        carrier âŸ¦ param op âŸ§áµ t' â†’
                        ({t'' : Time} â†’ t' + op-time op â‰¤ t'' â†’ carrier âŸ¦ arity op âŸ§áµ t'' â†’ TË¢ B Ï„'' t'') â†’
                        TË¢ B (op-time op + Ï„'') t')
               â†’ (h-nat : (op : Op) â†’ (Ï„'' : Time) â†’ {t t' : Time} â†’ (p : t â‰¤ t') â†’
                    (v : carrier âŸ¦ param op âŸ§áµ t) â†’
                    (k : {t'' : Time} â†’ t + op-time op â‰¤ t'' â†’ carrier âŸ¦ arity op âŸ§áµ t'' â†’ TË¢ B Ï„'' t'') â†’
                      h op _ (monotone (âŸ¦ param op âŸ§áµ) p v) (Î» q y â†’ k (â‰¤-trans (+-monoË¡-â‰¤ (op-time op) p) q) y)
                    â‰¡ TË¢-â‰¤t p (h op _ v k))
               â†’ (f : A â†’áµ— Táµ’ B Ï„')
               â†’ (c : TË¢ A Ï„ t)
               â†’ handleË¢ h f (TË¢-â‰¤t p c)
               â‰¡ TË¢-â‰¤t p (handleË¢ h f c)
handleË¢-â‰¤t-nat p h h-nat f (leaf v) =
  map-nat f p v
handleË¢-â‰¤t-nat p h h-nat f (node op v k) =
  trans
    (cong (Ï„-subst (sym (+-assoc (op-time op) _ _)))
      (h-nat op _ p v (Î» p y â†’ handleË¢ h f (k p y))))
    (sym (Ï„-subst-â‰¤t (sym (+-assoc (op-time op) _ _)) p
           (h op _ v (Î» p y â†’ handleË¢ h f (k p y)))))
handleË¢-â‰¤t-nat p h h-nat f (delay Ï„ k) =
  trans
    (cong (Ï„-subst (sym (+-assoc Ï„ _ _)))
      (cong (delay Ï„)
        (handleË¢-â‰¤t-nat (+-monoË¡-â‰¤ Ï„ p) h h-nat f k)))
    (sym (Ï„-subst-â‰¤t (sym (+-assoc Ï„ _ _)) p
           (delay Ï„ (handleË¢ h f k))))


handleáµ€ : âˆ€ {A B Ï„ Ï„'}
        â†’ ((op : Op) â†’ (Ï„'' : Time) â†’
             âŸ¦ param op âŸ§áµ Ã—áµ— ([ op-time op ]áµ’ (âŸ¦ arity op âŸ§áµ â‡’áµ— Táµ’ B Ï„'')) â†’áµ— Táµ’ B (op-time op + Ï„''))
        â†’ A â†’áµ— Táµ’ B Ï„'
        â†’ Táµ’ A Ï„ â†’áµ— Táµ’ B (Ï„ + Ï„')
handleáµ€ {A} {B} h f =
  tset-map
    (Î» c â†’ handleË¢
             (Î» op Ï„'' {t'} v k â†’
               map-carrier (h op Ï„'')
                 (v ,
                  subst id (sym (reveal-â‡’áµ— (âŸ¦ arity op âŸ§áµ) (Táµ’ B Ï„'') (t' + op-time op)))
                    (tset-map
                      (Î» { (q , y) â†’ k (subst id (reveal-homáµ’ (t' + op-time op) _) q) y })
                      (Î» { q (r , y) â†’ {!!} }))))                                               -- Need the continuation k to be monotone
             f c)                                                                               -- This does not follow from the raw inductive tree definition of TË¢
    {!!}                                                                                        -- Do we need to separately restrict to only trees whos continuations are monotone?
                                                                                                -- Because if we simply strengthen the h argument of handleË¢ when we cannot do
                                                                                                -- recursive calls there any more

-}



{-

(tset-map
                   (Î» { (q , y) â†’ k (â‰¤-trans {!!} (subst id (reveal-homáµ’ t' _) q)) y })
                   {!!})

-}


{-
handleáµ€ : âˆ€ {A B Ï„ Ï„'}
        â†’ ((op : Op) â†’ (Ï„'' : Time) â†’ {t' : Time} â†’
             carrier âŸ¦ param op âŸ§áµ t' â†’
             ({t'' : Time} â†’ t' + op-time op â‰¤ t'' â†’ carrier âŸ¦ arity op âŸ§áµ t'' â†’ TË¢ B Ï„'' t'') â†’
             TË¢ B (op-time op + Ï„'') t')
        â†’ A â†’áµ— Táµ’ B Ï„'
        â†’ Táµ’ A Ï„ â†’áµ— Táµ’ B (Ï„ + Ï„')
handleáµ€ h f =
  tset-map (handleË¢ h f) (Î» p c â†’ handleË¢-â‰¤t-nat p h f c)
-}


{-
               TË¢ B (op-time op + Ï„'') t')
               â†’ strË¢ {A = A} {B = B}
                   (monotone ([ Ï„ ]áµ’ (âŸ¨ Ï„' âŸ©áµ’ A)) p v)
                   (TË¢-â‰¤t p c)
               â‰¡ TË¢-â‰¤t p (strË¢ {A = A} {B = B} v c)
-}
